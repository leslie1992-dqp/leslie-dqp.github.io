<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"charming-c.github.io","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":"ture","bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="Java 讲解–核心技术第五章，第六章第五章继承一. 父类和子类，继承思想 利用继承，人们可以基于已经存在的类构造一个新类。继承已经存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。  java中继承是一个非常基础并且非常重要的内容，对于理解面向对象的思想非常重要">
<meta property="og:type" content="article">
<meta property="og:title" content="java-核心技术卷五,六章">
<meta property="og:url" content="https://charming-c.github.io/2020/11/14/java-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%BA%94-%E5%85%AD%E7%AB%A0/index.html">
<meta property="og:site_name" content="Charming-Zone">
<meta property="og:description" content="Java 讲解–核心技术第五章，第六章第五章继承一. 父类和子类，继承思想 利用继承，人们可以基于已经存在的类构造一个新类。继承已经存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。  java中继承是一个非常基础并且非常重要的内容，对于理解面向对象的思想非常重要">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-14T05:28:35.000Z">
<meta property="article:modified_time" content="2020-11-14T14:16:34.000Z">
<meta property="article:author" content="charming">
<meta property="article:tag" content="java">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://charming-c.github.io/2020/11/14/java-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%BA%94-%E5%85%AD%E7%AB%A0/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java-核心技术卷五,六章 | Charming-Zone</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Charming-Zone</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我的博客世界！</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E8%AE%B2%E8%A7%A3%E2%80%93%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%8C%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="nav-number">1.</span> <span class="nav-text">Java 讲解–核心技术第五章，第六章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%BB%A7%E6%89%BF"><span class="nav-number">1.1.</span> <span class="nav-text">第五章继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB%EF%BC%8C%E7%BB%A7%E6%89%BF%E6%80%9D%E6%83%B3"><span class="nav-number">1.1.1.</span> <span class="nav-text">一. 父类和子类，继承思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-%E5%A4%9A%E6%80%81"><span class="nav-number">1.1.2.</span> <span class="nav-text">二.多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.1.3.</span> <span class="nav-text">三.抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E8%80%81%E7%88%B6%E4%BA%B2%E2%80%93Object%E7%B1%BB%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D%EF%BC%8C%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E6%95%B0%E7%BB%84%EF%BC%8C%E5%8C%85%E8%A3%85%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="nav-number">1.1.4.</span> <span class="nav-text">四.老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E5%8F%8D%E5%B0%84"><span class="nav-number">1.1.5.</span> <span class="nav-text">五.反射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%8E%A5%E5%8F%A3%EF%BC%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">第六章 接口，lambda表达式与内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.1.</span> <span class="nav-text">六.接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">七.lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.2.3.</span> <span class="nav-text">八. 内部类</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="charming"
      src="/images/icon2.jpg">
  <p class="site-author-name" itemprop="name">charming</p>
  <div class="site-description" itemprop="description">所思，所感，所想。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/charming-c" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;charming-c" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://charming-c.github.io/2020/11/14/java-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%BA%94-%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon2.jpg">
      <meta itemprop="name" content="charming">
      <meta itemprop="description" content="所思，所感，所想。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Charming-Zone">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java-核心技术卷五,六章
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-11-14 13:28:35 / 修改时间：22:16:34" itemprop="dateCreated datePublished" datetime="2020-11-14T13:28:35+08:00">2020-11-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Java-讲解–核心技术第五章，第六章"><a href="#Java-讲解–核心技术第五章，第六章" class="headerlink" title="Java 讲解–核心技术第五章，第六章"></a>Java 讲解–核心技术第五章，第六章</h1><h2 id="第五章继承"><a href="#第五章继承" class="headerlink" title="第五章继承"></a>第五章继承</h2><h3 id="一-父类和子类，继承思想"><a href="#一-父类和子类，继承思想" class="headerlink" title="一. 父类和子类，继承思想"></a>一. 父类和子类，继承思想</h3><blockquote>
<p>利用继承，人们可以基于已经存在的类构造一个新类。继承已经存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。</p>
</blockquote>
<p>java中继承是一个非常基础并且非常重要的内容，对于理解面向对象的思想非常重要</p>
<a id="more"></a>

<p>比如我们定义一个Employee类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，用于初始化类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(LocalDate hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的类就规范了一个Employee（职员）具有的性质，比如姓名，薪水，雇佣日期。但是相比于普通（Employee）职员，还有一类特殊的人（Manager），他们除了拥有Employee的属性和方法，还有一些特殊的福利，比如他们有奖金（bonus），那我们写Manager类时，还要把上面的代码再写一遍，这样会导致代码出现大量的重复，而java针对这样的情形，就提供了继承的思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面几行代码就使得Manager拥有了Employee的属性和方法，同时构造器也覆盖了Employee的构造器，但要注意的是，</p>
<ul>
<li><strong>对于父类的（私有的）private修饰的属性和方法，子类是不可见的，子类如果要访问私有成员的话，只能调用具有更高访问权限的父类的方法去访问</strong></li>
<li>子类的方法不适用于父类的对象，而父类的方法子类是可适用于子类的</li>
<li>对于某些方法，子类可能与父类的有冲突，我们可以在子类利用通过重写同名方法将父类的方法覆盖掉，这样对于子类对象调用该方法的时候，会默认调用子类的方法</li>
<li>super关键字：就是让编译器去这个类的父类class文件里去检索调用方法，或者调用父类的构造方法</li>
<li>子类构造器：利用supper调用父类构造器必须是子类构造器的第一条语句;如果子类的构造器没有显式调用父类的构造器，则会自动调用父类的默认的没有参数的构造器，如果父类没有不带参的构造器，那么会编译报错。</li>
</ul>
<p>而针对子类所特有的属性和方法就在子类里加就好：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">      	bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bonus + <span class="keyword">super</span>.getSalary();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//	@Override</span></span><br><span class="line"><span class="comment">//    public double getSalary() &#123;</span></span><br><span class="line"><span class="comment">//      return bonus + salary;</span></span><br><span class="line"><span class="comment">//	return bonus + getSalary();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>继承层次</strong>：</p>
<blockquote>
<p>由一个公共父类派生出来的所有类的集合称为继承层次，在继承层次中，从某个特定的类到其祖先的类的路径被称为该类的继承链。</p>
</blockquote>
<p>Java是不支持多继承的，就是说一个子类只能继承自一个父类，不能有多个父类。</p>
<h3 id="二-多态"><a href="#二-多态" class="headerlink" title="二.多态"></a>二.多态</h3><p><strong>多态：</strong></p>
<p>父类的引用指向子类的对象，当我们声明一个父类的对象，它既可以引用一个父类的对象，也可以引用一个子类的对象，书上说的是，出现超类对象的任何地方都可以用子类的对象置换。反过来是不行的，不能将一个超类的引用赋给子类的变量。看下面的代码，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Employee e;</span><br><span class="line">        Manager staff2 = <span class="keyword">new</span> Manager(<span class="string">&quot;b&quot;</span>,<span class="number">5000</span>,<span class="number">2020</span>,<span class="number">11</span>,<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        e = staff2;</span><br><span class="line"></span><br><span class="line">        System.out.println(e.getClass());						</span><br><span class="line">        System.out.println(e <span class="keyword">instanceof</span> Employee);</span><br><span class="line">        System.out.println(e <span class="keyword">instanceof</span> Manager);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//结果：</span></span><br><span class="line">  <span class="comment">// class extend.Manager</span></span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>e被声明为一个Employee对象以后，把Employee的子类Manager的对象赋值给e后，我们发现它既是一个Manager实例，也是一个Employee实例，一个对象，两个状态，就是多态了</p>
<p>写了一个好玩的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Food food)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m eating &quot;</span>+food.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span>  <span class="title">Food</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Peach</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Peach&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.eat(<span class="keyword">new</span> Apple());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Banana());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Peach());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Food() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后打印出来的结果：    </p>
<blockquote>
<p>I’m eating Apple<br>I’m eating Banana<br>I’m eating Peach<br>I’m eating unknown</p>
</blockquote>
<p>在实现了Food接口以后，Apple类，Banan类还有Peach类都可以向上转型变为Food，也就是说他们的对象都可以当作food对象来用，当person调用eat方法的时候，可以把这些水果的对象传进，因为他们本身就是Food对象的实例，而调用food的getName方法的时候，就会优先检索具体实现类的方法，这里的多态不是继承里面的，但是思想一样。</p>
<h3 id="三-抽象类"><a href="#三-抽象类" class="headerlink" title="三.抽象类"></a>三.抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描述，但并非所有的类都用来来描述对象，如果一个类中没有包含足够的信息来描述一个具体的对象，这样的类就可以作为抽象类。</p>
<p>举个例子：所有的动物（animal）都可以移动（move），可以吃东西（eat），但是不同的动物，它移动或者吃东西都是不一样的，必须由具体的种类实现，比如鱼是游，吃蚯蚓，蛇是爬行，吃老鼠，这样，我们把移动和吃东西抽象出来写成一个抽象类，让他的子类去实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snack</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蛇是爬行动物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蛇是吃老鼠的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鱼在水里游&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鱼吃蚯蚓&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Snack snack = <span class="keyword">new</span> Snack();</span><br><span class="line">        Fish fish = <span class="keyword">new</span> Fish();</span><br><span class="line">        snack.move();</span><br><span class="line">        snack.eat();</span><br><span class="line">        fish.move();</span><br><span class="line">        fish.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>蛇是爬行动物<br>蛇是吃老鼠的<br>鱼在水里游<br>鱼吃蚯蚓</p>
</blockquote>
<p>抽象类除了不能实例化对象，类的其他功能仍然存在（可以有构造器，但不一定要有抽象方法），所有抽象类必须要被继承后才可以使用</p>
<p>抽象方法：如果想要设计一个类，包含一个特别的成员方法，该方法的具体实现由他的子类确定，可以在父类中声明为抽象方法（抽象方法是没有方法体的），那么这个类也就是抽象类了（不写abstract会报错），任何继承了这个抽象类的子类都必须重写这个抽象方法，或者声明自己是一个抽象类，其中构造方法和静态方法是不能被声明为抽象的。</p>
<p><strong>为什么抽象类也要有一个构造器呢？</strong></p>
<p>1.首先要知道JAVA中的构造器，不是用来实例化对象的，而是用来初始化的。</p>
<p>2.抽象类中并不都是抽象方法，里面有成员变量，构造器是用来给这些成员变量赋值的。</p>
<p>【补充】：abstract只能用来修饰类和方法，不能用来修饰属性。</p>
<p>3.要知道抽象类是用来继承的，为什么用来继承，一般是用来实现多态！那么我们知道，在new一个子类对象的时候，默认调用了super();</p>
<p>那如果没有构造器，这个super怎么调用啊。</p>
<h3 id="四-老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱"><a href="#四-老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱" class="headerlink" title="四.老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱"></a>四.老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱</h3><p><strong>Object类</strong>：如果一个类继承了其他父类，就不会直接继承Object，但是它的父类如果再没有父类，就会继承Object，也就是说，Object是任何一个类的直接或间接的父类。因此，我们随意创建一个类，其实也不是空的，起码这个类中有Object类中的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function">pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	Example example = <span class="keyword">new</span> Example();</span><br><span class="line">	System.out.println(example.equals(<span class="keyword">null</span>));</span><br><span class="line">        System.out.println(example.getClass());</span><br><span class="line">        System.out.println(example.hashCode());</span><br><span class="line">        System.out.println(example.toString());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>false<br>class extend.Example<br>603742814<br>extend.Example@23fc625e</p>
</blockquote>
<p><strong>简单介绍一下Object里的几个方法</strong>：</p>
<ol>
<li><p>equals()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>由方法定义可知，Object类中的equals方法，用来比较两个引用的虚地址。当且仅当两个引用在物理上是同一个对象时，返回值为true，否则将返回false。</p>
</li>
<li><p><strong>注意：</strong>当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</li>
</ol>
<ol start="2">
<li><p>hashCode()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>native含义native方法称为本地方法。在java源程序中以关键字“native”声明，不提供函数体。<br>其实现使用C/C++语言在另外的文件中编写，编写的规则遵循Java本地接口的规范(简称JNI)。<br>简而言就是Java中声明的可调用的使用C/C++实现的方法。</p>
</li>
</ol>
<ol start="3">
<li><p>总之不管怎么生成的散列码，在Object 类里，equals返回为true，则hashCode是相同的</p>
</li>
<li><p>书上讲了一下String类复写的hashCode（）方法：</p>
<ol>
<li><blockquote>
<p>int hash = 0;</p>
<p>for(int i = 0; i &lt; length(); i++){</p>
<p>​    hash = 31 * hash + charAt(i);</p>
<p>}</p>
</blockquote>
</li>
<li><p>所以对于String类的对象来说来说，只要内容是一样的，则他们散列码就是一样的，而书中的StringBuilder类，没有定义hashCode()方法，所以必须要是一个对象或者一个对象的引用才会返回一样的散列码。</p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>getClass()方法：</p>
<ol>
<li>返回运行时包含对象信息的类对象,后面反射再说</li>
</ol>
</li>
<li><p>toString()方法：</p>
<ol>
<li><p>返回表示对象值的字符串，没有重写的话，就是一个类名接着一个字符串</p>
<blockquote>
<p>extend.Example@23fc625e</p>
</blockquote>
</li>
<li><p>一般会重写这个方法打印一个对象的基本信息</p>
</li>
</ol>
</li>
</ol>
<p><strong>泛型数组列表</strong>：ArrayList&lt;类型名&gt;(数量)；</p>
<ol>
<li><p>泛型就是广泛的类型，这里的泛型数组就是可以存放某个特定类型的对象的数组，比如</p>
<blockquote>
<p>ArrayList&lt; Employee &gt; staff = new ArrayList&lt;&gt;(100);</p>
<p>这里就规定这个泛型数组存放Employee对象，且容量设置为100，注意泛型数组的容量可以不设置，不像c语言一样，声明就必须规定大小，并且泛型数组会自动扩容，当这里超过100个元素就会自动扩容。</p>
</blockquote>
</li>
<li><p>可以用add()方法和get()方法添加和访问数组元素，方法都比较简单。</p>
</li>
</ol>
<p><strong>对象包装器和自动装箱</strong>：</p>
<p>对象包装器类是不可变的，一旦构造了包装器，由于他的值被final修饰，就无法改变包装在其中的值，同时类被final修饰，不能被继承</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td>Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td>Short</td>
</tr>
<tr>
<td align="center">int</td>
<td>Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td>Long</td>
</tr>
<tr>
<td align="center">float</td>
<td>Float</td>
</tr>
<tr>
<td align="center">double</td>
<td>Double</td>
</tr>
<tr>
<td align="center">char</td>
<td>Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>​      Integer里的value和构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>之前介绍的泛型数组当要储存基本类型数据时，由于&lt;&gt;里必须是类型参数，所以只能填类型名，而不能填基本数据类型，只能写成<code> ArrayList&lt;Integer&gt;()</code>这样的</p>
<p>简单的装箱和拆箱：</p>
<p>泛型数组里给我提供了这样一个便利：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> n = list.get(i);</span><br></pre></td></tr></table></figure>

<p>其实根据ArrayList的定义，里面存放的是一个个对象，但是为什么往里面可以直接add一基本数据类型呢，从数组里拿出来的为什么是int，而不是integer对象呢？</p>
<p>其实这就是java的自动装箱和拆箱，表面上看，编译器执行的是list.add(3),其实由于自动装箱，编译器执行到这里的时候自动把3转化为Integer.valueOf(3)这是一个静态的构造方法，会返回一个integer对象,打包成一个Integer对象，送进了泛型数组里。同里取出的时候，也会把取出的Integer对象通过intValue()方法转成一个int数据。</p>
<h3 id="五-反射"><a href="#五-反射" class="headerlink" title="五.反射"></a>五.反射</h3><p>Class类对象：</p>
<p><code> Person p = new Person();</code>执行这样一行代码，机器里的操作就是，在文件夹里寻找Person.java,然后javac编译为.class的字节码文件，再通过jvm的类加载器将其加载到堆中，创建一个Class类对象，这个对象不是一般的对象，它所包含的事是类的所有信息，然后通过调用里面的方法new 出一个普通的Person对象，反射主要就是通过获得这样一个Class类对象，可以在运行时检查类、接口、方法和变量等信息，无需知道类的名字，方法名等。还可以在运行时实例化新对象，调用方法以及设置和获取变量值。</p>
<p>java中提供3种方法获取内存中的Class对象</p>
<ol>
<li>Class.forName()方式适用于运行时动态获取Class对象，只需将类名作为forName方法的参数：</li>
<li>类名.class</li>
<li>对象.getClass();</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	Person p = <span class="keyword">new</span> Person();</span><br><span class="line">	Class class1 = p.getClass();</span><br><span class="line">        Class class2 = Person.class;</span><br><span class="line">        Class class3 = Class.forName(<span class="string">&quot;extend.Person&quot;</span>);</span><br><span class="line"><span class="comment">//			获得类对象</span></span><br><span class="line">        System.out.println(class1);</span><br><span class="line">        System.out.println(class2);</span><br><span class="line">        System.out.println(class3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>class extend.Person<br>class extend.Person<br>class extend.Person</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	Class class1 = p.getClass();</span><br><span class="line">        Class class2 = Person.class;</span><br><span class="line">        Class class3 = Class.forName(<span class="string">&quot;extend.Person&quot;</span>);</span><br><span class="line"><span class="comment">//		获得接口</span></span><br><span class="line">        Class[] interfaces= class1.getInterfaces();</span><br><span class="line"><span class="comment">//		获得构造器</span></span><br><span class="line">        Constructor constructor = class1.getConstructor();</span><br><span class="line"><span class="comment">//		获得方法</span></span><br><span class="line">        Method[] methods = class1.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m: methods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(interfaces.length);</span><br><span class="line">        System.out.println(class1.getPackageName());</span><br><span class="line">        System.out.println(constructor);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>public void extend.Person.eat(extend.Food)<br>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>public boolean java.lang.Object.equals(java.lang.Object)<br>public java.lang.String java.lang.Object.toString()<br>public native int java.lang.Object.hashCode()<br>public final native java.lang.Class java.lang.Object.getClass()<br>public final native void java.lang.Object.notify()<br>public final native void java.lang.Object.notifyAll()<br>0<br>extend<br>public extend.Person()<br>class extend.Person<br>class extend.Person<br>class extend.Person</p>
</blockquote>
<p>除了获得信息，可以看到包括方法，构造器，甚至接口都被我们保存到相应的实例里，我们可以通过调用这些实例来使用方法，构造器等等，反射是很有意思的东西，大家感兴趣可以玩一玩。</p>
<h2 id="第六章-接口，lambda表达式与内部类"><a href="#第六章-接口，lambda表达式与内部类" class="headerlink" title="第六章 接口，lambda表达式与内部类"></a>第六章 接口，lambda表达式与内部类</h2><h3 id="六-接口"><a href="#六-接口" class="headerlink" title="六.接口"></a>六.接口</h3><p>一个类通过实现接口的方式，来实现接口中的各种方法，接口中的默认声明为public abstract（公共抽象的），接口和抽象类一样是不能被实例化的，接口的使用方式就是让其他的类去实现它，或者别的接口继承，其实最后也是要被类实现，进而实现里面的抽象方法</p>
<ul>
<li>一个实现接口的类，必须实现接口的所有抽象方法，否则就要声明为抽象类</li>
<li>接口类型可以用来声明一个变量，他们可以成为一个空指针，或者被绑定为一个实现了此接口的对象</li>
<li>接口中可以定义常量，默认都是（static final），但是不能有实例域</li>
<li>可以用default修饰一个接口的方法，使得这个接口有一个默认实现</li>
</ul>
<p>实现一个接口，就要重写其中的抽象方法，继承一个抽象类，也要实现其中的抽象方法，如果做不到，就要自己声明为抽象类，我们可以简单比较一下抽象类和接口：</p>
<blockquote>
<p>区别一: 抽象类只能单继承,接口能多实现<br>区别二: 抽象类是一个类,可以被任意权限修饰符修饰,静态和非静态属性，final和非final属性，可<br>以有抽象方法和非抽象方法；<br>接口只能被public,final修饰,只能有静态方法,即使没有显示的声明，而且是不可修改的；<br>区别三: 抽象的事物不同:<br>抽象类是对整个类抽象,包括属性,行为；接口是对类的行为(局部)进行抽象；<br>区别四: 定义的时候,定义抽象类和接口的思想不同；<br>设计抽象类是自下而上的过程,我子类需要,所以我定义抽象类；<br>设计接口是自上而下的过程,我接口规范某一行为,我某类需要这个行为,我实现某接口</p>
</blockquote>
<p><strong>接口和回调</strong>：</p>
<p>回调：</p>
<p>书上的例子也挺好，就是用一个计时器，每隔一定时间，发送一事件，然后再通过实现的接口的自定义方法去执行一些操作，书上的例子包装的很好。</p>
<p>类A调用类B的b方法 类B的b方法执行完毕主动调用类A的callback()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//		这里的Customer我们实现了一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个方法就是我们要去执行时，会回来调用callback接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderWakeUp</span><span class="params">(Hotel hotel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;顾客订购叫醒服务！&quot;</span>);</span><br><span class="line">        hotel.goToWakeUp(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;顾客被叫醒了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hotel</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过调用这个方法，回调回之前的对象的方法，核心是这里的参数用接口的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToWakeUp</span><span class="params">(CallBack callBack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟时间</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;过了一会……&quot;</span>);</span><br><span class="line">            callBack.wakeUp();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Hotel hotel = <span class="keyword">new</span> Hotel();</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.orderWakeUp(hotel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>顾客订购叫醒服务！<br>过了一会……<br>顾客被叫醒了！</p>
</blockquote>
<h3 id="七-lambda表达式"><a href="#七-lambda表达式" class="headerlink" title="七.lambda表达式"></a>七.lambda表达式</h3><p>形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( params ) -&gt; expression;<span class="comment">//返回表达式的值</span></span><br><span class="line">( params ) -&gt; statement; <span class="comment">//返回void</span></span><br><span class="line">( params ) -&gt; &#123; statements &#125;;</span><br><span class="line"><span class="comment">//如果代码要完成的计算无法放在一个表达式里面，就可以像写方法一样写在一个&#123;&#125;里，并要包含显示的return语句。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果方法没有参数，也要像方法一样留一个空括号</li>
<li>当lambda表达式只在一些分支返回值，而其他时候不返回，是会报错的</li>
</ul>
<p>自己的理解：lambda表达式的就像是一个包装的方法，没有说明方法的名称和返回类型，但是规定了参数的传入，以及返回的值，整个lambda更像是一个一次性的方法，最后的结果就是箭头后的返回值。</p>
<p><strong>函数式接口</strong>：对于只有一个抽象方法的接口，需要这种接口的对象时，我们可以提供一个lambda 表达式,lambda表达式可以转为接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.eat(<span class="keyword">new</span> Apple());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Banana());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Peach());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Food() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      	p.eat(()-&gt;<span class="string">&quot;lambda...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>I’m eating Apple<br>I’m eating Banana<br>I’m eating Peach<br>I’m eating unknown<br>I’m eating lambda…</p>
</blockquote>
<p>这里的eat本来是传入一个Food的实例的，但是Food作为一个只有一个抽象方法的接口，刚好可以用lambda书写，只需要注意其抽象方法返回的是String，这样的lambda表达式刚好从一个类似于方法的东西在这里转型为接口使用。</p>
<h3 id="八-内部类"><a href="#八-内部类" class="headerlink" title="八. 内部类"></a>八. 内部类</h3><p>主要分为四类：</p>
<ol>
<li>成员内部类（成员内部类不允许存在任何static修饰的变量和方法，正如成员方法中不能有任何静态属性一样（成员方法与对象有关，静态变量与类有关），成员内部类与外部类的实例相联系，可以访问外部类的所有成员数据，正因为成员内部类与外部类的实例联系，因此它不允许在 方法区（Method Area）中申请内存，只能在 堆（Heap）中 申请，所以不能在其内部定义static成员变量，可以理解成内存上的一种包含关系。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<ol start="2">
<li><p>静态内部类</p>
<ol>
<li><p>被关键字static修饰的成员内部类就是静态内部类</p>
</li>
<li><p>静态内部类的创建不依赖于外部类，而可以直接创建</p>
</li>
<li><p>静态内部类不可以使用任何外部类的非static类（包括属性和方法—），但可以自己存在自己的成员变量</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<ol start="3">
<li><p>方法（局部）内部类</p>
<ol>
<li><p>定义在方法内部的一个类，方法内部类不允许使用访问修饰符（别的地方也没有理由可以使用它），因为方法内部类对外部完全隐藏，除了创建这个类的方法可以访问到他，其他都不可以</p>
</li>
<li><p>方法内部类如果要使用形参，该形参就要修饰为final</p>
<ol>
<li>原因：局部变量和局部内部类的生命周期是不一致的，当局部变量所处的函数执行完毕后，就会被销毁，但局部内部类的对象还可能一直存在（若该对象仍然被引用），而当对象要访问该局部变量时，访问的就是不存在的东西了，用final修饰就会将这个局部变量复制一份，并一直保存了这个拷贝每次访问时就能找到这个拷贝</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner2</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span> <span class="keyword">extends</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">              String s = <span class="string">&quot;Inner2&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Inner2();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>匿名内部类</p>
<ol>
<li><p>用得最多的内部类，一个没有名字的方法内部类，</p>
</li>
<li><p>匿名内部类继承一个抽象类，或者实现一个接口</p>
</li>
<li><p>匿名内部类没有类名，因此也没有构造方法，不能有静态方法和属性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.eat(<span class="keyword">new</span> Food() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"><i class = "fa fa-tags"></i> java</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"><i class = "fa fa-tags"></i> 编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/30/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/" rel="prev" title="排序算法">
                  <i class="fa fa-chevron-left"></i> 排序算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/10/git%E7%AE%80%E4%BB%8B/" rel="next" title="git简介">
                  git简介 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">charming</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">67k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:01</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
<br /> 
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("09/01/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  

</body>
</html>
