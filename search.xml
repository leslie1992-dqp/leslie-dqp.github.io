<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java-IO流</title>
    <url>/2020/09/10/Java-IO%E6%B5%81/</url>
    <content><![CDATA[<p>简单介绍java的io流的概念</p>
<h1 id="一、IO概念"><a href="#一、IO概念" class="headerlink" title="一、IO概念"></a>一、IO概念</h1><ul>
<li>I/O就是input和output的缩写，是计算机调度把各个储存中（包括内存和外部储存）的数据写入写出的过程</li>
<li>所谓的外部设备可以包括硬盘文件, 网络设备, 另个程序等. 也就是当前程序之外的数据设备</li>
<li>java中用流（stream）来抽象表示这么一个写入写出的功能，封装成一个类，都放在java.io这个包里面</li>
</ul>
<a id="more"></a>
<h1 id="二、流（stream）的概念"><a href="#二、流（stream）的概念" class="headerlink" title="二、流（stream）的概念"></a>二、流（stream）的概念</h1><ul>
<li>stream（流）是从起源（source）到接收（sink）的有序数据。</li>
<li>如果把输入输出源比作“水桶”的话，“流”就相当于是连接他们的“管道”，这个管道的粗细、单向性等各种属性就是区分不同流的特性，流中的各种方法就是管道上的按钮，用于操作数据的流通。<br><img src="https://img-blog.csdnimg.cn/20200802143851170.jpg" alt="在这里插入图片描述"><h1 id="三、IO流的分类"><a href="#三、IO流的分类" class="headerlink" title="三、IO流的分类"></a>三、IO流的分类</h1><h2 id="1、按照流的方向"><a href="#1、按照流的方向" class="headerlink" title="1、按照流的方向"></a>1、按照流的方向</h2></li>
<li>输入流：只能从中读取数据（主要由InputStream和Reader作为基类）</li>
<li>输出流：只能向其写入数据（主要由OutputStream和Writer作为基类）<h2 id="2、按照流的操作颗粒度划分"><a href="#2、按照流的操作颗粒度划分" class="headerlink" title="2、按照流的操作颗粒度划分"></a>2、按照流的操作颗粒度划分</h2></li>
<li>字节流：以字节为单位，可操作任何数据（主要以InputStream和OutputStream作为基类）</li>
<li>字符流：以字符为单位，只能操作纯字符数据，比较方便（主要以Reader和Writer为基类）<h2 id="3、按照流的角色划分"><a href="#3、按照流的角色划分" class="headerlink" title="3、按照流的角色划分"></a>3、按照流的角色划分</h2></li>
<li>节点流：可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，也叫低级流。</li>
<li>处理流：用于对一个已经存在的流进行连接和封装，通过封装后的流实现数据的读/写功能，也叫高级流。<h1 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h1>InputStream是Java标准库提供的最基本的输入流。InputStream是一个抽象类，是所有输入类的超类。这个抽象类定义的最重要的方法就是int read（）这样的一个方法</li>
</ul>
<blockquote>
<p> public abstract int read() throws IOException;<br> 这个方法会读取输入流的下一个字节，并返回字节表示的int值。如果己经&gt;  读到末尾，返回-1，表示不能继续读取了</p>
</blockquote>
<p>FileInputStream是InputStream的一个子类，可以用来从文件中获得数据，下面的代码演示了如何完整读取一个文件的字节：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      InputStream inputStream&#x3D;new FileInputStream(&quot;src&#x2F;sample.txt&quot;);</span><br><span class="line">        for(;;)&#123;</span><br><span class="line">            int n&#x3D;inputStream.read();</span><br><span class="line">            if(n&#x3D;&#x3D;-1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：在计算机中，类似文件，网络端口这些资源，都是由操作系统统一管理，应用程序在运行的时候，如果打开了一个文件进行读写，完成后要及时关闭，以便操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存还会影响其他应用程序的运行。</p>
<h2 id="1-缓冲"><a href="#1-缓冲" class="headerlink" title="1.缓冲"></a>1.缓冲</h2><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节的效率要高很多。InputStream提供两个重载方法来支持读取多个字节：</p>
<blockquote>
<p>int read(byte[] b): 读取若干字节填充到byte[]数组，返回读取的字节数<br>int read(byte[] b,int off,int len): 指定byte[]数组的偏移量和最大填充数</p>
</blockquote>
<p>利用上述方法读取多个字节时需要先定义一个byte[]数组作为缓冲区，read()会尽可能多的读取字节到缓冲区，但不会超过缓冲区容量的大小，read（）的返回值变为实际读取的字节数。若返回-1，则表示没有更多数据了。<br>栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException&#123;</span><br><span class="line">      InputStream inputStream&#x3D;new FileInputStream(&quot;src&#x2F;sample.txt&quot;);</span><br><span class="line">        byte[] butter&#x3D;new byte[5];</span><br><span class="line">        int n;</span><br><span class="line">        while((n&#x3D;inputStream.read(butter))!&#x3D;-1)&#123;</span><br><span class="line">            System.out.println(&quot;read&quot;+n+&quot;bytes\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-阻塞"><a href="#2-阻塞" class="headerlink" title="2.阻塞"></a>2.阻塞</h2><p>在调用InputStream的read()方法时，我们说它是阻塞的</p>
<blockquote>
<p>int n;<br>n=inputStream.read();<br>m=n;</p>
</blockquote>
<p>执行到第二行时，必须等read（）方法返回后才可以继续。因为读取IO流比普通代码速度要慢很多，无法确定read（）方法到底要花费多长时间，所以它是阻塞的。</p>
<h1 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h1><p>和InputStream相反，OutputStream是Java库中提供的最基本的输出流。<br>和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的最重要的方法是void write(int b):</p>
<blockquote>
<p> public abstract void write(int b) throws IOException;</p>
</blockquote>
<p>这个方法会写入一个字节到输出流。要注意，虽然传入的是int类型的参数，但只会写入一个字节，即只写入int最低8位表示字节的部分。</p>
<ul>
<li>和InputStream一样，也有close（）方法，write（）也是阻塞的</li>
<li>OutputStream还提供了一个flush()方法，它的作用是将缓冲区的内容真正输入到目的地。</li>
</ul>
<p>为什么要有flush()方法？因为向网络、磁盘写入数据的时候，出于效率考虑，操作系统并不是输出一个字节就立马写入到文件或发送到网络，而是把输出的字节先放到内存的一个缓冲区（本质上也是一个byte[]数组），等到缓冲区写满，在一次性发送。对于很多IO设备，一次性写一个字节和一次性写1000个字节花费的时间几乎是一样的，所以这个flush方法的存在，就是强制把缓冲区的flush输出。</p>
<p>以FileOutputStream为例，演示将若干字节写入文件流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line"> OutputStream outputStream &#x3D; new FileOutputStream(&quot;src&#x2F;sample.txt&quot;);</span><br><span class="line">        outputStream.write(108);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Filter模式"><a href="#Filter模式" class="headerlink" title="Filter模式"></a>Filter模式</h1><ul>
<li>如果我们要给一个FileInputStream添加缓冲功能，则可以从FileInputStream派生出一个类<blockquote>
<p>BufferedFileInputStream extends FileInputstream</p>
</blockquote>
</li>
<li>如果我们要给一个FileInputStream添加计算签名功能，则可以派生一个类<blockquote>
<p>DigestFileInputStream extends FileInputstream</p>
</blockquote>
</li>
<li>若要添加加密解密功能，还可以派生一个类<blockquote>
<p>CipherFileInputStream extends FileInputstream</p>
</blockquote>
</li>
</ul>
<p>如果要给一个FileInputStream添加以上三种功能，用继承的方法实现的话，子类会比较多，实现的功能越多，子类就越复杂。因此直接使用继承的方法，为InputStream添加很多功能，根本无法控制代码的复杂度。</p>
<p>为了解决依赖继承导致子类数量失控的问题，JDK首先将InputStream分成两大类：</p>
<ol>
<li>直接提供数据的基础InputStream，例如<ul>
<li>FileInputStream</li>
<li>ByteArrayInputStream</li>
</ul>
</li>
<li>提供额外附加功能的InputStream。例如</li>
</ol>
<ul>
<li>BufferedInputStream</li>
<li>DigestInputStream</li>
</ul>
<p>当我们给一个基础的的InputStream附加各种功能时，我们先确定这个提供数据源的InputStream，即第一类Inputstream<br>例如：</p>
<blockquote>
<p>Inputstream file= new FileInputStream(“test.gz”);</p>
</blockquote>
<p>紧接着我们希望FileInputStream能提供缓冲的功能来提高读取效率，因此我们可以用BufferedInputStream来包装这个InputStream，得到的包装类型是BufferedInputStream，他仍可视为InputStream：</p>
<blockquote>
<p>InputStream buffered= new BufferedInputStream(file);</p>
</blockquote>
<p>无论包装了多少次，得到的对象始终是InputStream，我们zhijieyongInputStream来引用它，皆可以正常读取。</p>
<p>同理，OutputStream也是如此，这样的一种通过一个基础组件再叠加各种“附加”功能组件的模式，就叫做Filter模式。</p>
<h1 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h1><p>Reader是Java IO库提供的另一个输入流接口。和InputStream的区别是，Reader是一个字符流，以char为单位读取，而后者是一个字节流，以byte为单位。<br>|InputStream| Reader |<br>|–|–|<br>|字节流，byte  | 字符流，char |<br>|读取字节（-1，0<del>255):int read()|读取字符（-1，0</del>65535):int read()|<br>Reader定义了所有字符输入流的超类：</p>
<ul>
<li>FileReader实现了文字字符流的输入，使用时注意制定编码</li>
<li>CharArrayReader和StringReader可以在内存中模拟一个字符流输入</li>
</ul>
<p>Reader 是基于inputStream构造的：可以通过InPutStreanReader在制定编码的同时讲一个InputStream转化为Reader。</p>
<blockquote>
<p>Reader reader=new InputStreamReader(new FileInPutstream(“文件名路径”，“编码”));</p>
</blockquote>
<h1 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h1><p>Writer和OutputStream的联系与上面Reader差不多，不再赘述。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-类加载机制</title>
    <url>/2020/10/10/java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="一、什么是java的类加载"><a href="#一、什么是java的类加载" class="headerlink" title="一、什么是java的类加载"></a>一、什么是java的类加载</h1><p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p>
<ul>
<li>编译</li>
<li>运行</li>
</ul>
<p><strong>编译</strong>，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。</p>
<p><strong>运行</strong>，则是把编译生成的.class文件交给Java虚拟机(JVM)执行。</p>
<p>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。而这个类对象会包含成员变量、构造方法、成语方法等信息。</p>
<a id="more"></a>

<p><img src="https://user-gold-cdn.xitu.io/2018/2/12/1618814efa703be5?imageslim"></p>
<p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。* .class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象（类对象），通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等。</p>
<p><strong>举例</strong>： JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。并且这种加载的操作只会进行一次</p>
<h1 id="二、java类加载的流程"><a href="#二、java类加载的流程" class="headerlink" title="二、java类加载的流程"></a>二、java类加载的流程</h1><p><img src="https://user-gold-cdn.xitu.io/2018/2/12/1618817ff24341a3?imageslim"></p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p>加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。并为之创建一个java.lang.class对象。</p>
<p><img src="https://i.loli.net/2020/10/10/O3wGhyU8QIZFPsn.png" alt="84873221AC165DF03B0B6AA89CF31BFE.png"></p>
<ul>
<li><strong>字节码文件来源</strong>：一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li>
<li><strong>类加载器</strong>：一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>应用类加载器</strong>，以及用户的<strong>自定义类加载器</strong>。</li>
</ul>
<ol>
<li><p>启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
<li><p>自定义类加载器：若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。</p>
</li>
</ol>
<p><strong>结论</strong>：加载阶段，虚拟机需要完成以下三件事情：</p>
<ol>
<li><p>通过一个类的全限定名来获取其定义的二进制字节流。</p>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
</li>
<li><p>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
</li>
</ol>
<h2 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a><strong>2.验证</strong></h2><p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。</p>
<p>包括对于<strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p>
<p>对于<strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p>
<p>对于<strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证类型转换的合理性。</p>
<p>对于<strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
<h2 id="3-准备"><a href="#3-准备" class="headerlink" title="3.准备"></a><strong>3.准备</strong></h2><p>主要是为类变量（静态变量）（注意，不是实例变量）分配内存，并且赋予<strong>初值</strong>。</p>
<p>特别需要注意，<strong>初值，不是代码中具体写的初始化的值</strong>，而是Java虚拟机根据不同变量类型的默认初始值。</p>
<p>比如8种<strong>基本类型</strong>的初值，默认为0；<strong>引用类型</strong>的初值则为null；<strong>常量</strong>的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456。</p>
<h2 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a><strong>4.解析</strong></h2><p>将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</li>
<li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li>
</ul>
<p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p>
<p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h2 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5.初始化"></a><strong>5.初始化</strong></h2><p>这个阶段主要是对<strong>类变量</strong>初始化，是执行类构造器的过程。</p>
<p>换句话说，只对static修饰的变量或语句进行初始化。</p>
<p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p>
<p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<p>JVM初始化执行<strong>构造器方法</strong>的过程：</p>
<p>1）类构造器方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。</p>
<p>2）类构造器方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的类构造器方法执行之前，父类的类构造器方法已经执行完毕，因此在虚拟机中第一个执行的类构造器方法的类一定是java.lang.Object。</p>
<p>3）由于父类的类构造器方法方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p>
<p>4）类构造器方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成类构造器方法。</p>
<p>5）接口中可能会有变量赋值操作，因此接口也会生成类构造器方法。但是接口与类不同，执行接口的类构造器方法不需要先执行父接口的类构造器方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也不会执行接口的类构造器方法。</p>
<p>6）虚拟机会保证一个类的类构造器方法在多线程环境中被正确地加锁和同步。如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的类构造器方法，其它线程都需要阻塞等待，直到活动线程执行类构造器方法完毕。如果在一个类的类构造器方法中有耗时很长的操作，那么就可能造成多个进程阻塞。</p>
<h2 id="三、什么时候开始类的初始化"><a href="#三、什么时候开始类的初始化" class="headerlink" title="三、什么时候开始类的初始化"></a>三、什么时候开始类的初始化</h2><p>什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于初始化阶段虚拟机规范是严格规定了如下几种情况，如果类未初始化会对类进行初始化。</p>
<p>1、创建类的实例</p>
<p>2、访问类的静态变量(除常量【被final修辞的静态变量】)</p>
<p>3、访问类的静态方法</p>
<p>4、反射如(Class.forName(“my.xyz.Test”))</p>
<p>5、当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化</p>
<p>6、虚拟机启动时，定义了main()方法的那个类先初始化</p>
<h2 id="四、简单分析"><a href="#四、简单分析" class="headerlink" title="四、简单分析"></a>四、简单分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        count1++;  </span><br><span class="line">        count2++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> singleTon;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();  </span><br><span class="line">        System.out.println(<span class="string">&quot;count1=&quot;</span> + singleTon.count1);  </span><br><span class="line">        System.out.println(<span class="string">&quot;count2=&quot;</span> + singleTon.count2);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1:SingleTon singleTon = SingleTon.getInstance();调用了类的SingleTon调用了类的静态方法，触发类的初始化</p>
<p>2:类加载的时候在准备过程中为类的静态变量分配内存并初始化默认值 singleton=null count1=0,count2=0</p>
<p>3:类初始化化，为类的静态变量赋值和执行静态代码快。singleton赋值为new SingleTon()调用类的构造方法</p>
<p>4:调用类的构造方法后count=1;count2=1</p>
<p>5:继续为count1与count2赋值,此时count1没有赋值操作,所有count1为1,但是count2执行赋值操作就变为0。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-核心技术卷五,六章</title>
    <url>/2020/11/14/java-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%BA%94-%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="Java-讲解–核心技术第五章，第六章"><a href="#Java-讲解–核心技术第五章，第六章" class="headerlink" title="Java 讲解–核心技术第五章，第六章"></a>Java 讲解–核心技术第五章，第六章</h1><h2 id="第五章继承"><a href="#第五章继承" class="headerlink" title="第五章继承"></a>第五章继承</h2><h3 id="一-父类和子类，继承思想"><a href="#一-父类和子类，继承思想" class="headerlink" title="一. 父类和子类，继承思想"></a>一. 父类和子类，继承思想</h3><blockquote>
<p>利用继承，人们可以基于已经存在的类构造一个新类。继承已经存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。</p>
</blockquote>
<p>java中继承是一个非常基础并且非常重要的内容，对于理解面向对象的思想非常重要</p>
<a id="more"></a>

<p>比如我们定义一个Employee类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    <span class="keyword">private</span> LocalDate hireDay;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，用于初始化类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = LocalDate.of(year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getHireDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHireDay</span><span class="params">(LocalDate hireDay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hireDay = hireDay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">raiseSalary</span><span class="params">(<span class="keyword">double</span> byPercent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> raise = salary * byPercent / <span class="number">100</span>;</span><br><span class="line">        salary += raise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的类就规范了一个Employee（职员）具有的性质，比如姓名，薪水，雇佣日期。但是相比于普通（Employee）职员，还有一类特殊的人（Manager），他们除了拥有Employee的属性和方法，还有一些特殊的福利，比如他们有奖金（bonus），那我们写Manager类时，还要把上面的代码再写一遍，这样会导致代码出现大量的重复，而java针对这样的情形，就提供了继承的思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面几行代码就使得Manager拥有了Employee的属性和方法，同时构造器也覆盖了Employee的构造器，但要注意的是，</p>
<ul>
<li><strong>对于父类的（私有的）private修饰的属性和方法，子类是不可见的，子类如果要访问私有成员的话，只能调用具有更高访问权限的父类的方法去访问</strong></li>
<li>子类的方法不适用于父类的对象，而父类的方法子类是可适用于子类的</li>
<li>对于某些方法，子类可能与父类的有冲突，我们可以在子类利用通过重写同名方法将父类的方法覆盖掉，这样对于子类对象调用该方法的时候，会默认调用子类的方法</li>
<li>super关键字：就是让编译器去这个类的父类class文件里去检索调用方法，或者调用父类的构造方法</li>
<li>子类构造器：利用supper调用父类构造器必须是子类构造器的第一条语句;如果子类的构造器没有显式调用父类的构造器，则会自动调用父类的默认的没有参数的构造器，如果父类没有不带参的构造器，那么会编译报错。</li>
</ul>
<p>而针对子类所特有的属性和方法就在子类里加就好：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> bonus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">      	bonus = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBonus</span><span class="params">(<span class="keyword">double</span> bonus)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bonus = bonus;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bonus + <span class="keyword">super</span>.getSalary();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//	@Override</span></span><br><span class="line"><span class="comment">//    public double getSalary() &#123;</span></span><br><span class="line"><span class="comment">//      return bonus + salary;</span></span><br><span class="line"><span class="comment">//	return bonus + getSalary();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>继承层次</strong>：</p>
<blockquote>
<p>由一个公共父类派生出来的所有类的集合称为继承层次，在继承层次中，从某个特定的类到其祖先的类的路径被称为该类的继承链。</p>
</blockquote>
<p>Java是不支持多继承的，就是说一个子类只能继承自一个父类，不能有多个父类。</p>
<h3 id="二-多态"><a href="#二-多态" class="headerlink" title="二.多态"></a>二.多态</h3><p><strong>多态：</strong></p>
<p>父类的引用指向子类的对象，当我们声明一个父类的对象，它既可以引用一个父类的对象，也可以引用一个子类的对象，书上说的是，出现超类对象的任何地方都可以用子类的对象置换。反过来是不行的，不能将一个超类的引用赋给子类的变量。看下面的代码，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Employee e;</span><br><span class="line">        Manager staff2 = <span class="keyword">new</span> Manager(<span class="string">&quot;b&quot;</span>,<span class="number">5000</span>,<span class="number">2020</span>,<span class="number">11</span>,<span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">        e = staff2;</span><br><span class="line"></span><br><span class="line">        System.out.println(e.getClass());						</span><br><span class="line">        System.out.println(e <span class="keyword">instanceof</span> Employee);</span><br><span class="line">        System.out.println(e <span class="keyword">instanceof</span> Manager);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//结果：</span></span><br><span class="line">  <span class="comment">// class extend.Manager</span></span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line">	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>e被声明为一个Employee对象以后，把Employee的子类Manager的对象赋值给e后，我们发现它既是一个Manager实例，也是一个Employee实例，一个对象，两个状态，就是多态了</p>
<p>写了一个好玩的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Food food)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m eating &quot;</span>+food.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span>  <span class="title">Food</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Peach</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Peach&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.eat(<span class="keyword">new</span> Apple());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Banana());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Peach());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Food() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后打印出来的结果：    </p>
<blockquote>
<p>I’m eating Apple<br>I’m eating Banana<br>I’m eating Peach<br>I’m eating unknown</p>
</blockquote>
<p>在实现了Food接口以后，Apple类，Banan类还有Peach类都可以向上转型变为Food，也就是说他们的对象都可以当作food对象来用，当person调用eat方法的时候，可以把这些水果的对象传进，因为他们本身就是Food对象的实例，而调用food的getName方法的时候，就会优先检索具体实现类的方法，这里的多态不是继承里面的，但是思想一样。</p>
<h3 id="三-抽象类"><a href="#三-抽象类" class="headerlink" title="三.抽象类"></a>三.抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描述，但并非所有的类都用来来描述对象，如果一个类中没有包含足够的信息来描述一个具体的对象，这样的类就可以作为抽象类。</p>
<p>举个例子：所有的动物（animal）都可以移动（move），可以吃东西（eat），但是不同的动物，它移动或者吃东西都是不一样的，必须由具体的种类实现，比如鱼是游，吃蚯蚓，蛇是爬行，吃老鼠，这样，我们把移动和吃东西抽象出来写成一个抽象类，让他的子类去实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snack</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蛇是爬行动物&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;蛇是吃老鼠的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鱼在水里游&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鱼吃蚯蚓&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Snack snack = <span class="keyword">new</span> Snack();</span><br><span class="line">        Fish fish = <span class="keyword">new</span> Fish();</span><br><span class="line">        snack.move();</span><br><span class="line">        snack.eat();</span><br><span class="line">        fish.move();</span><br><span class="line">        fish.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>蛇是爬行动物<br>蛇是吃老鼠的<br>鱼在水里游<br>鱼吃蚯蚓</p>
</blockquote>
<p>抽象类除了不能实例化对象，类的其他功能仍然存在（可以有构造器，但不一定要有抽象方法），所有抽象类必须要被继承后才可以使用</p>
<p>抽象方法：如果想要设计一个类，包含一个特别的成员方法，该方法的具体实现由他的子类确定，可以在父类中声明为抽象方法（抽象方法是没有方法体的），那么这个类也就是抽象类了（不写abstract会报错），任何继承了这个抽象类的子类都必须重写这个抽象方法，或者声明自己是一个抽象类，其中构造方法和静态方法是不能被声明为抽象的。</p>
<p><strong>为什么抽象类也要有一个构造器呢？</strong></p>
<p>1.首先要知道JAVA中的构造器，不是用来实例化对象的，而是用来初始化的。</p>
<p>2.抽象类中并不都是抽象方法，里面有成员变量，构造器是用来给这些成员变量赋值的。</p>
<p>【补充】：abstract只能用来修饰类和方法，不能用来修饰属性。</p>
<p>3.要知道抽象类是用来继承的，为什么用来继承，一般是用来实现多态！那么我们知道，在new一个子类对象的时候，默认调用了super();</p>
<p>那如果没有构造器，这个super怎么调用啊。</p>
<h3 id="四-老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱"><a href="#四-老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱" class="headerlink" title="四.老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱"></a>四.老父亲–Object类相关介绍，泛型数组数组，包装和自动装箱</h3><p><strong>Object类</strong>：如果一个类继承了其他父类，就不会直接继承Object，但是它的父类如果再没有父类，就会继承Object，也就是说，Object是任何一个类的直接或间接的父类。因此，我们随意创建一个类，其实也不是空的，起码这个类中有Object类中的属性和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Example</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function">pubic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	Example example = <span class="keyword">new</span> Example();</span><br><span class="line">	System.out.println(example.equals(<span class="keyword">null</span>));</span><br><span class="line">        System.out.println(example.getClass());</span><br><span class="line">        System.out.println(example.hashCode());</span><br><span class="line">        System.out.println(example.toString());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>false<br>class extend.Example<br>603742814<br>extend.Example@23fc625e</p>
</blockquote>
<p><strong>简单介绍一下Object里的几个方法</strong>：</p>
<ol>
<li><p>equals()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>由方法定义可知，Object类中的equals方法，用来比较两个引用的虚地址。当且仅当两个引用在物理上是同一个对象时，返回值为true，否则将返回false。</p>
</li>
<li><p><strong>注意：</strong>当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>
</li>
</ol>
<ol start="2">
<li><p>hashCode()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>native含义native方法称为本地方法。在java源程序中以关键字“native”声明，不提供函数体。<br>其实现使用C/C++语言在另外的文件中编写，编写的规则遵循Java本地接口的规范(简称JNI)。<br>简而言就是Java中声明的可调用的使用C/C++实现的方法。</p>
</li>
</ol>
<ol start="3">
<li><p>总之不管怎么生成的散列码，在Object 类里，equals返回为true，则hashCode是相同的</p>
</li>
<li><p>书上讲了一下String类复写的hashCode（）方法：</p>
<ol>
<li><blockquote>
<p>int hash = 0;</p>
<p>for(int i = 0; i &lt; length(); i++){</p>
<p>​    hash = 31 * hash + charAt(i);</p>
<p>}</p>
</blockquote>
</li>
<li><p>所以对于String类的对象来说来说，只要内容是一样的，则他们散列码就是一样的，而书中的StringBuilder类，没有定义hashCode()方法，所以必须要是一个对象或者一个对象的引用才会返回一样的散列码。</p>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>getClass()方法：</p>
<ol>
<li>返回运行时包含对象信息的类对象,后面反射再说</li>
</ol>
</li>
<li><p>toString()方法：</p>
<ol>
<li><p>返回表示对象值的字符串，没有重写的话，就是一个类名接着一个字符串</p>
<blockquote>
<p>extend.Example@23fc625e</p>
</blockquote>
</li>
<li><p>一般会重写这个方法打印一个对象的基本信息</p>
</li>
</ol>
</li>
</ol>
<p><strong>泛型数组列表</strong>：ArrayList&lt;类型名&gt;(数量)；</p>
<ol>
<li><p>泛型就是广泛的类型，这里的泛型数组就是可以存放某个特定类型的对象的数组，比如</p>
<blockquote>
<p>ArrayList&lt; Employee &gt; staff = new ArrayList&lt;&gt;(100);</p>
<p>这里就规定这个泛型数组存放Employee对象，且容量设置为100，注意泛型数组的容量可以不设置，不像c语言一样，声明就必须规定大小，并且泛型数组会自动扩容，当这里超过100个元素就会自动扩容。</p>
</blockquote>
</li>
<li><p>可以用add()方法和get()方法添加和访问数组元素，方法都比较简单。</p>
</li>
</ol>
<p><strong>对象包装器和自动装箱</strong>：</p>
<p>对象包装器类是不可变的，一旦构造了包装器，由于他的值被final修饰，就无法改变包装在其中的值，同时类被final修饰，不能被继承</p>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td>Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td>Short</td>
</tr>
<tr>
<td align="center">int</td>
<td>Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td>Long</td>
</tr>
<tr>
<td align="center">float</td>
<td>Float</td>
</tr>
<tr>
<td align="center">double</td>
<td>Double</td>
</tr>
<tr>
<td align="center">char</td>
<td>Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>​      Integer里的value和构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>之前介绍的泛型数组当要储存基本类型数据时，由于&lt;&gt;里必须是类型参数，所以只能填类型名，而不能填基本数据类型，只能写成<code> ArrayList&lt;Integer&gt;()</code>这样的</p>
<p>简单的装箱和拆箱：</p>
<p>泛型数组里给我提供了这样一个便利：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> n = list.get(i);</span><br></pre></td></tr></table></figure>

<p>其实根据ArrayList的定义，里面存放的是一个个对象，但是为什么往里面可以直接add一基本数据类型呢，从数组里拿出来的为什么是int，而不是integer对象呢？</p>
<p>其实这就是java的自动装箱和拆箱，表面上看，编译器执行的是list.add(3),其实由于自动装箱，编译器执行到这里的时候自动把3转化为Integer.valueOf(3)这是一个静态的构造方法，会返回一个integer对象,打包成一个Integer对象，送进了泛型数组里。同里取出的时候，也会把取出的Integer对象通过intValue()方法转成一个int数据。</p>
<h3 id="五-反射"><a href="#五-反射" class="headerlink" title="五.反射"></a>五.反射</h3><p>Class类对象：</p>
<p><code> Person p = new Person();</code>执行这样一行代码，机器里的操作就是，在文件夹里寻找Person.java,然后javac编译为.class的字节码文件，再通过jvm的类加载器将其加载到堆中，创建一个Class类对象，这个对象不是一般的对象，它所包含的事是类的所有信息，然后通过调用里面的方法new 出一个普通的Person对象，反射主要就是通过获得这样一个Class类对象，可以在运行时检查类、接口、方法和变量等信息，无需知道类的名字，方法名等。还可以在运行时实例化新对象，调用方法以及设置和获取变量值。</p>
<p>java中提供3种方法获取内存中的Class对象</p>
<ol>
<li>Class.forName()方式适用于运行时动态获取Class对象，只需将类名作为forName方法的参数：</li>
<li>类名.class</li>
<li>对象.getClass();</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	Person p = <span class="keyword">new</span> Person();</span><br><span class="line">	Class class1 = p.getClass();</span><br><span class="line">        Class class2 = Person.class;</span><br><span class="line">        Class class3 = Class.forName(<span class="string">&quot;extend.Person&quot;</span>);</span><br><span class="line"><span class="comment">//			获得类对象</span></span><br><span class="line">        System.out.println(class1);</span><br><span class="line">        System.out.println(class2);</span><br><span class="line">        System.out.println(class3);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>class extend.Person<br>class extend.Person<br>class extend.Person</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	Class class1 = p.getClass();</span><br><span class="line">        Class class2 = Person.class;</span><br><span class="line">        Class class3 = Class.forName(<span class="string">&quot;extend.Person&quot;</span>);</span><br><span class="line"><span class="comment">//		获得接口</span></span><br><span class="line">        Class[] interfaces= class1.getInterfaces();</span><br><span class="line"><span class="comment">//		获得构造器</span></span><br><span class="line">        Constructor constructor = class1.getConstructor();</span><br><span class="line"><span class="comment">//		获得方法</span></span><br><span class="line">        Method[] methods = class1.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m: methods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(interfaces.length);</span><br><span class="line">        System.out.println(class1.getPackageName());</span><br><span class="line">        System.out.println(constructor);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>public void extend.Person.eat(extend.Food)<br>public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>public boolean java.lang.Object.equals(java.lang.Object)<br>public java.lang.String java.lang.Object.toString()<br>public native int java.lang.Object.hashCode()<br>public final native java.lang.Class java.lang.Object.getClass()<br>public final native void java.lang.Object.notify()<br>public final native void java.lang.Object.notifyAll()<br>0<br>extend<br>public extend.Person()<br>class extend.Person<br>class extend.Person<br>class extend.Person</p>
</blockquote>
<p>除了获得信息，可以看到包括方法，构造器，甚至接口都被我们保存到相应的实例里，我们可以通过调用这些实例来使用方法，构造器等等，反射是很有意思的东西，大家感兴趣可以玩一玩。</p>
<h2 id="第六章-接口，lambda表达式与内部类"><a href="#第六章-接口，lambda表达式与内部类" class="headerlink" title="第六章 接口，lambda表达式与内部类"></a>第六章 接口，lambda表达式与内部类</h2><h3 id="六-接口"><a href="#六-接口" class="headerlink" title="六.接口"></a>六.接口</h3><p>一个类通过实现接口的方式，来实现接口中的各种方法，接口中的默认声明为public abstract（公共抽象的），接口和抽象类一样是不能被实例化的，接口的使用方式就是让其他的类去实现它，或者别的接口继承，其实最后也是要被类实现，进而实现里面的抽象方法</p>
<ul>
<li>一个实现接口的类，必须实现接口的所有抽象方法，否则就要声明为抽象类</li>
<li>接口类型可以用来声明一个变量，他们可以成为一个空指针，或者被绑定为一个实现了此接口的对象</li>
<li>接口中可以定义常量，默认都是（static final），但是不能有实例域</li>
<li>可以用default修饰一个接口的方法，使得这个接口有一个默认实现</li>
</ul>
<p>实现一个接口，就要重写其中的抽象方法，继承一个抽象类，也要实现其中的抽象方法，如果做不到，就要自己声明为抽象类，我们可以简单比较一下抽象类和接口：</p>
<blockquote>
<p>区别一: 抽象类只能单继承,接口能多实现<br>区别二: 抽象类是一个类,可以被任意权限修饰符修饰,静态和非静态属性，final和非final属性，可<br>以有抽象方法和非抽象方法；<br>接口只能被public,final修饰,只能有静态方法,即使没有显示的声明，而且是不可修改的；<br>区别三: 抽象的事物不同:<br>抽象类是对整个类抽象,包括属性,行为；接口是对类的行为(局部)进行抽象；<br>区别四: 定义的时候,定义抽象类和接口的思想不同；<br>设计抽象类是自下而上的过程,我子类需要,所以我定义抽象类；<br>设计接口是自上而下的过程,我接口规范某一行为,我某类需要这个行为,我实现某接口</p>
</blockquote>
<p><strong>接口和回调</strong>：</p>
<p>回调：</p>
<p>书上的例子也挺好，就是用一个计时器，每隔一定时间，发送一事件，然后再通过实现的接口的自定义方法去执行一些操作，书上的例子包装的很好。</p>
<p>类A调用类B的b方法 类B的b方法执行完毕主动调用类A的callback()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//		这里的Customer我们实现了一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个方法就是我们要去执行时，会回来调用callback接口的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderWakeUp</span><span class="params">(Hotel hotel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;顾客订购叫醒服务！&quot;</span>);</span><br><span class="line">        hotel.goToWakeUp(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;顾客被叫醒了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hotel</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过调用这个方法，回调回之前的对象的方法，核心是这里的参数用接口的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goToWakeUp</span><span class="params">(CallBack callBack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟时间</span></span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;过了一会……&quot;</span>);</span><br><span class="line">            callBack.wakeUp();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Hotel hotel = <span class="keyword">new</span> Hotel();</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.orderWakeUp(hotel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>顾客订购叫醒服务！<br>过了一会……<br>顾客被叫醒了！</p>
</blockquote>
<h3 id="七-lambda表达式"><a href="#七-lambda表达式" class="headerlink" title="七.lambda表达式"></a>七.lambda表达式</h3><p>形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">( params ) -&gt; expression;<span class="comment">//返回表达式的值</span></span><br><span class="line">( params ) -&gt; statement; <span class="comment">//返回void</span></span><br><span class="line">( params ) -&gt; &#123; statements &#125;;</span><br><span class="line"><span class="comment">//如果代码要完成的计算无法放在一个表达式里面，就可以像写方法一样写在一个&#123;&#125;里，并要包含显示的return语句。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果方法没有参数，也要像方法一样留一个空括号</li>
<li>当lambda表达式只在一些分支返回值，而其他时候不返回，是会报错的</li>
</ul>
<p>自己的理解：lambda表达式的就像是一个包装的方法，没有说明方法的名称和返回类型，但是规定了参数的传入，以及返回的值，整个lambda更像是一个一次性的方法，最后的结果就是箭头后的返回值。</p>
<p><strong>函数式接口</strong>：对于只有一个抽象方法的接口，需要这种接口的对象时，我们可以提供一个lambda 表达式,lambda表达式可以转为接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.eat(<span class="keyword">new</span> Apple());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Banana());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Peach());</span><br><span class="line">        p.eat(<span class="keyword">new</span> Food() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      	p.eat(()-&gt;<span class="string">&quot;lambda...&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>I’m eating Apple<br>I’m eating Banana<br>I’m eating Peach<br>I’m eating unknown<br>I’m eating lambda…</p>
</blockquote>
<p>这里的eat本来是传入一个Food的实例的，但是Food作为一个只有一个抽象方法的接口，刚好可以用lambda书写，只需要注意其抽象方法返回的是String，这样的lambda表达式刚好从一个类似于方法的东西在这里转型为接口使用。</p>
<h3 id="八-内部类"><a href="#八-内部类" class="headerlink" title="八. 内部类"></a>八. 内部类</h3><p>主要分为四类：</p>
<ol>
<li>成员内部类（成员内部类不允许存在任何static修饰的变量和方法，正如成员方法中不能有任何静态属性一样（成员方法与对象有关，静态变量与类有关），成员内部类与外部类的实例相联系，可以访问外部类的所有成员数据，正因为成员内部类与外部类的实例联系，因此它不允许在 方法区（Method Area）中申请内存，只能在 堆（Heap）中 申请，所以不能在其内部定义static成员变量，可以理解成内存上的一种包含关系。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<ol start="2">
<li><p>静态内部类</p>
<ol>
<li><p>被关键字static修饰的成员内部类就是静态内部类</p>
</li>
<li><p>静态内部类的创建不依赖于外部类，而可以直接创建</p>
</li>
<li><p>静态内部类不可以使用任何外部类的非static类（包括属性和方法—），但可以自己存在自己的成员变量</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<ol start="3">
<li><p>方法（局部）内部类</p>
<ol>
<li><p>定义在方法内部的一个类，方法内部类不允许使用访问修饰符（别的地方也没有理由可以使用它），因为方法内部类对外部完全隐藏，除了创建这个类的方法可以访问到他，其他都不可以</p>
</li>
<li><p>方法内部类如果要使用形参，该形参就要修饰为final</p>
<ol>
<li>原因：局部变量和局部内部类的生命周期是不一致的，当局部变量所处的函数执行完毕后，就会被销毁，但局部内部类的对象还可能一直存在（若该对象仍然被引用），而当对象要访问该局部变量时，访问的就是不存在的东西了，用final修饰就会将这个局部变量复制一份，并一直保存了这个拷贝每次访问时就能找到这个拷贝</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner2</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Inner2</span> <span class="keyword">extends</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">              String s = <span class="string">&quot;Inner2&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Inner2();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>匿名内部类</p>
<ol>
<li><p>用得最多的内部类，一个没有名字的方法内部类，</p>
</li>
<li><p>匿名内部类继承一个抽象类，或者实现一个接口</p>
</li>
<li><p>匿名内部类没有类名，因此也没有构造方法，不能有静态方法和属性</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.eat(<span class="keyword">new</span> Food() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>java-集合框架</title>
    <url>/2020/09/10/java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="1-集合"><a href="#1-集合" class="headerlink" title="1. 集合"></a>1. 集合</h1><p>集合可以看作是一个容器，用来储存<strong>对象</strong>信息。我们都知道数组可以用来保存<strong>多个数据或者对象</strong>的，那为什么java中还有着比如<strong>List，Map，Set</strong>这样的集合类呢？说明数组有一定的局限性，比如：</p>
<ul>
<li>数组长度是固定的,不能自动增长<br><code> String[] array3=new String[5];</code>  <code>String[] array=&#123;&quot;hello&quot;,&quot;world&quot;&#125;</code>;<br>无论是动态初始化还是静态初始化，在创建的时候，我们就需要声明数组的大小，这样虚拟机才会分配一个连续的内存空间来存储数组。假如此时我又有了新的数据，但是由于我们的数组已经满了，因此新的数据无法保存，我们只能创建一个更大的数组来保存数组，而无法在原有基础上进行扩展。</li>
<li>其次，我们在数组里保存了很多数据，但是只是单一的数据而已，如果我们需要保存映射的关系，比如<strong>Key-value</strong>关系，那么数组就无法满足我们了。</li>
</ul>
<p>针对这些，java在<code>java.util</code>里提供了集合类。</p>
<a id="more"></a>

<h1 id="2-集合类的基本框架"><a href="#2-集合类的基本框架" class="headerlink" title="2.集合类的基本框架"></a>2.集合类的基本框架</h1><ul>
<li>集合类主要有四种Set,Queue,List,Map</li>
<li>Set表示无序且元素互异的集合，有点像数学里面学到的集合</li>
<li>List表示有序的且集合内元素可重复的集合</li>
<li>Map表示有映射关系的集合</li>
<li>Queue表示队列<br>（队列：一种只允许在<strong>表的前端进行删除操作</strong>且在<strong>表的后端进行插入操作</strong>的线性表。队列遵循先进先出原则（first in first out））<br><img src="https://img-blog.csdnimg.cn/20200626192628335.png" alt="队列单向"><br>他们的基本关系有以下两个图表示：<br><img src="https://img-blog.csdnimg.cn/20200627161605728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYXJtaW5nY2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202006271621555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYXJtaW5nY2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h1 id="3-Colloction接口"><a href="#3-Colloction接口" class="headerlink" title="3.Colloction接口"></a>3.Colloction接口</h1>从上面的图可以看到Set，Queue，List都实现了Collection的接口</li>
<li><code>int size();</code> 返回集合中元素的个数</li>
<li><code>boolean isEmpty()</code>判断集合是否为空</li>
<li><code>boolean contains（object o）</code>判断是否存在指定元素</li>
<li><code>Iterator&lt;E&gt; iterator();</code>返回一个Iterator对象，用来遍历集合中的元素</li>
<li><code>Object[] toArray();</code>返回一个包含这个集合所有元素的Object类数组（若集合有序的话，返回的数组是同序的）</li>
<li><code>&lt;T&gt; T[] toArray(T[] a);</code>和前面一个方法作用是一样的，不过返回的是指定的泛型T的一个数组</li>
<li><code> boolean add(E e);</code>向集合添加一个元素</li>
<li><code>boolean remove（Object o)</code>删除指定 的元素，如果包含一个或者多个元素o,则这些元素都会被删除</li>
<li><code>boolean containsAll(Collection&lt;?&gt; c);</code>判断是否包含集合c中的全部元素</li>
</ul>
<p>里面方法很多不一一列举</p>
<h1 id="4-Iterator迭代器"><a href="#4-Iterator迭代器" class="headerlink" title="4.Iterator迭代器"></a>4.Iterator迭代器</h1><ul>
<li>查看Collection接口源码，可以看到<code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</code></li>
<li>实现iterable接口的原因就是为集合类创立一个iterator对象，可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构 ( 迭代器把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构)<br>Iterator又称为遍历器，通常我们可以通过它来遍历Collecion集合中的元素，但是java中的iterator比较简单，只能单向遍历。</li>
</ul>
<ol>
<li><p>使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p>
</li>
<li><p>使用next()获得序列中的下一个元素。</p>
</li>
<li><p>使用hasNext()检查序列中是否还有元素。</p>
</li>
<li><p>使用remove()将迭代器新返回的元素删除。</p>
<h1 id="5-Set集合"><a href="#5-Set集合" class="headerlink" title="5.Set集合"></a>5.Set集合</h1><p>Set是Collection的一个子接口<code>public interface Set&lt;E&gt; extends Collection&lt;E&gt; </code></p>
</li>
</ol>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>无序，没有前后顺序的分别（这里指添加的时候的顺序），所有的元素没有位置的概念，所有的元素都在集合中。（好比一个罐子里面装东西一样，不分顺序，都装在这个罐子里）</li>
<li>无索引，每个元素没有特定的编号</li>
<li>不可重复，元素只有值的区别，没有位置的区别，如果重复，无法区分。<br><img src="https://img-blog.csdnimg.cn/20200626225253579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYXJtaW5nY2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<p>结果<br><img src="https://img-blog.csdnimg.cn/20200626225345534.png" alt="在这里插入图片描述"><br>这就很好的反映了set的无序和互异的特性</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Set本身和Collection的源码一样，没有什么特别的方法</p>
<h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><h3 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h3><ul>
<li>HashSet实现元素有序不重复的机制<blockquote>
<p>HashSet会调用该对象的hashCode（）方法来得到该对象的hashCode值，<br>然后根据该hashCode值决定该对象在hashSet中的存储位置。如果有两个元素通过equals()方法比较返回true,<br>   但它们的hashCode()返回值不相等，HashSet将会把它们存储在不同的位置，依然可以添加成功。<br>   也就是说HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等,并且两个对象的hashCode()方法返回值也相等。</p>
</blockquote>
</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Person&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[Person{age=10, name=’abc’}, Person{age=10, name=’a’}, Person{age=10, name=’a’}]</p>
</blockquote>
<p>重写方法hashCode和equals方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了equals方法&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">if</span>(((Person) o).age==person.getAge()&amp;&amp;((Person) o).name==person.getName()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了hashCode方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">55</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>调用了hashCode方法<br>调用了hashCode方法<br>调用了equals方法<br>调用了hashCode方法<br>调用了equals方法<br>[Person{age=10, name=’abc’}]</p>
</blockquote>
<h3 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2. LinkedHashSet"></a>2. LinkedHashSet</h3><ul>
<li><p>是Hashet的子类，具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现，即按照将元素插入到 set 中的顺序（插入顺序）进行迭代。</p>
</li>
<li><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p>
</li>
<li><p>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<h3 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3. TreeSet"></a>3. TreeSet</h3><p>TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet, Cloneable, java.io.Serializable接口。</p>
</li>
<li><p>TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。</p>
</li>
<li><p>TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。</p>
</li>
<li><p>TreeSet 实现了Cloneable接口，意味着它能被克隆。</p>
</li>
<li><p>TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。</p>
</li>
<li><p>TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。</p>
</li>
<li><p>TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。</p>
</li>
</ul>
<p>简单看看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带比较器的构造函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;(comparator));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回TreeSet的逆序排列的迭代器。</span></span><br><span class="line">  <span class="comment">// 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m.descendingKeySet().iterator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回Set的比较器</span></span><br><span class="line">  <span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator() &#123;</span><br><span class="line">      <span class="keyword">return</span> m.comparator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Set的第一个元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m.firstKey();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Set的最后一个元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">last</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m.lastKey();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Set中小于e的最大元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">lower</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m.lowerKey(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Set中小于/等于e的最大元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">floor</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m.floorKey(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Set中大于/等于e的最小元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">ceiling</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m.ceilingKey(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Set中大于e的最小元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">higher</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> m.higherKey(e);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>写了一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//        构造TreeSet时，传入person的比较年龄的方法</span></span><br><span class="line">        TreeSet&lt;Person&gt; tree=<span class="keyword">new</span> TreeSet&lt;&gt;(Person::compareTo);</span><br><span class="line">        tree.add(<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        tree.add(<span class="keyword">new</span> Person(<span class="number">20</span>,<span class="string">&quot;b&quot;</span>));</span><br><span class="line">        tree.add(<span class="keyword">new</span> Person(<span class="number">30</span>,<span class="string">&quot;c&quot;</span>));</span><br><span class="line">        tree.add(<span class="keyword">new</span> Person(<span class="number">40</span>,<span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="comment">//        年龄较小，而TreeSet是有序列的，无法放到集合中</span></span><br><span class="line">        tree.add(<span class="keyword">new</span> Person(<span class="number">10</span>,<span class="string">&quot;e&quot;</span>));</span><br><span class="line">        System.out.println(tree);</span><br><span class="line"><span class="comment">//        返回年龄小于30的人里年龄最大的人</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Lower a:&quot;</span>+tree.lower(<span class="keyword">new</span> Person(<span class="number">30</span>,<span class="string">&quot;n&quot;</span>)));</span><br><span class="line"><span class="comment">//        TreeSet不支持快速随机遍历，只能通过迭代器进行遍历</span></span><br><span class="line"><span class="comment">//        可以倒序遍历</span></span><br><span class="line">        Iterator iterator=tree.descendingIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) System.out.println(iterator.next());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果：</p>
<blockquote>
<p>[Person{age=10, name=’a’}, Person{age=20, name=’b’}, Person{age=30, name=’c’}, Person{age=40, name=’d’}]<br>Lower a:Person{age=20, name=’b’}<br>Person{age=40, name=’d’}<br>Person{age=30, name=’c’}<br>Person{age=20, name=’b’}<br>Person{age=10, name=’a’}</p>
</blockquote>
<h1 id="6-Queue队列"><a href="#6-Queue队列" class="headerlink" title="6.Queue队列"></a>6.Queue队列</h1><p>继承了Collection接口，方法比较简单，都是针对队列性质的操作</p>
<blockquote>
<p>add(E e):添加一个元素<br>remove():删除一个元素<br>offer(E e):添加一个元素<br>poll(E e):删除一个元素<br>peek():查看最上一个元素<br>element() ：查看最上一个元素,与上面不同的是会在队列为空的时候抛出一个异常</p>
</blockquote>
<h2 id="实现类-PriorityQueue"><a href="#实现类-PriorityQueue" class="headerlink" title="实现类: PriorityQueue"></a>实现类: PriorityQueue</h2><p>PriorityQueue是一个比较标准的队列实现类。之所以说它是比较标准的队列实现，而不是绝对标准的队列实现，是因为PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是会按队列元素的大小或指定的比较器进行重新排序(像是二叉树排列)。因此当调用peek()方法或者poll()方法取出队列中的元素时，并不是取出最先进入队列的元素，而是取出队列中最小的元素。这就违反队列的最基本原则：先进先出(FIFO)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PriorityQueue priorityQueue1=<span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        priorityQueue1.offer(-<span class="number">2</span>);</span><br><span class="line">        priorityQueue1.offer(<span class="number">10</span>);</span><br><span class="line">        priorityQueue1.offer(<span class="number">5</span>);</span><br><span class="line">        priorityQueue1.offer(<span class="number">6</span>);</span><br><span class="line">        priorityQueue1.offer(<span class="number">7</span>);</span><br><span class="line">        priorityQueue1.offer(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(priorityQueue1);</span><br><span class="line">        priorityQueue1.poll();</span><br><span class="line">        System.out.println(priorityQueue1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[-2, 6, 5, 10, 7, 8]<br>[5, 6, 8, 10, 7]</p>
</blockquote>
<h1 id="7-List列表"><a href="#7-List列表" class="headerlink" title="7.List列表"></a>7.List列表</h1><p>几个Collection接口里没有的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E get（<span class="keyword">int</span> index）：返回列表中指定位置的元素。</span><br><span class="line">E set（<span class="keyword">int</span> index，E element）：用指定的元素替换列表中指定位置的元素。</span><br><span class="line">List &lt;E&gt; subList（<span class="keyword">int</span> fromIndex，<span class="keyword">int</span> toIndex）：返回指定fromIndex（包含）和toIndex（不包括）之间的此</span><br><span class="line">列表部分的视图。返回的列表由此列表支持，因此返回列表中的非结构更改将反映在此列表中，反之亦然。</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> replaceAll（UnaryOperator &lt;E&gt;运算符）：将此列表的每个元素替换为将运算符应用于该元素的结果。</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> sort（Comparator &lt;<span class="keyword">super</span> E&gt; c）：根据指定的Comparator引发的顺序对此列表进行排序。</span><br><span class="line"><span class="keyword">default</span> Spliterator &lt;E&gt; spliterator（）：在此列表中的元素上创建Spliterator。</span><br></pre></td></tr></table></figure>
<p>有两种方法可以对列表进行排序。我们可以使用Collections类进行自然排序，或者我们可以使用List sort（）方法并使用我们自己的Comparator进行排序</p>
<h2 id="实现类-1"><a href="#实现类-1" class="headerlink" title="实现类"></a>实现类</h2><h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1. ArrayList"></a>1. ArrayList</h3><p>底层是基于动态数组，根据下表随机访问数组元素的效率高，向数组尾部添加元素的效率高；但是，删除数组中的数据以及向数组中间添加数据效率低，因为需要移动数组。例如最坏的情况是删除第一个数组元素，则需要将第2至第n个数组元素各向前移动一位。而之所以称为动态数组，是因为Arraylist在数组元素超过其容量大，Arraylist可以进行扩容（针对JDK1.8  数组扩容后的容量是扩容前的1.5倍），Arraylist源码中最大的数组容量是Integer.MAX_VALUE-8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h3><p>LinkedList底层的数据结构是基于双向链表的，且头结点中不存放数据,如下：<br><img src="https://img-blog.csdnimg.cn/202006271619086.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYXJtaW5nY2o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>既然是双向链表，那么必定存在一种数据结构——我们可以称之为节点，节点实例保存业务数据，前一个节点的位置信息和后一个节点位置信息，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200627162004574.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>具体源码</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Pointer to last node.</span></span><br><span class="line"><span class="comment">    * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">    *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>节点类很简单，element存放业务数据，prev与next分别存放前后节点的信息.具体的各种方法的实现不详细解释。</p>
<p>LinkedList 和 ArrayList 一样，都实现了 List 接口，但其内部的数据结构有本质的不同。LinkedList 是基于链表实现的（通过名字也能区分开来），所以它的插入和删除操作比 ArrayList 更加高效。但也是由于其为基于链表的，所以随机访问的效率要比 ArrayList 差。</p>
<h1 id="8-Map图"><a href="#8-Map图" class="headerlink" title="8.Map图"></a>8.Map图</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。</li>
<li>当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常.</li>
<li>当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。</li>
<li>当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。</li>
<li>当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2>插入元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>获取元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.get(<span class="string">&quot;key1&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>移除元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.remove(<span class="string">&quot;key1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>清空map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.clear();</span><br></pre></td></tr></table></figure>

<h2 id="实现类（内容有点多，下次再写完）"><a href="#实现类（内容有点多，下次再写完）" class="headerlink" title="实现类（内容有点多，下次再写完）"></a>实现类（内容有点多，下次再写完）</h2>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/10/30/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="十大排序"><a href="#十大排序" class="headerlink" title="十大排序"></a>十大排序</h1><h2 id="引言：-排序简单介绍"><a href="#引言：-排序简单介绍" class="headerlink" title="引言： 排序简单介绍"></a>引言： 排序简单介绍</h2><p>首先排序是最基本的一类算法，对于我们来说学好排序也是算法入门的一个很好的开始，在介绍排序之前首先介绍一下排序中的几个基本概念：</p>
<ol>
<li><p>稳定排序：将数组中的元素排序以后，若原来的集合里有相同的元素，则相同的元素在排序以后，相对的位置不变，比如：</p>
<blockquote>
<p>[3,7,2,3,1,9]        用a表示前面的3，b表示后面的3</p>
<p>则排序以后就有：</p>
<p>[1,2,a,b,7,9]        这样a代表的3依然在b代表的3的前面</p>
<p>就称这样的排序方法是稳定的</p>
</blockquote>
</li>
<li><p>原地排序：在排序算法实现的过程中，不申请多余的存储空间，只利用原来用来存储待排数据的存储空间进行比较和交换的排序。</p>
</li>
<li><p>时间复杂度：一个算法执行所需要花费的时间(一般用代码块的循环次数衡量)</p>
</li>
<li><p>空间复杂度：运行完一个算法的所需要的内存空间</p>
</li>
</ol>
<a id="more"></a>

<p>排序主要分为两类，主要是比较排序和非比较排序，其中又分成好几个种类，大致可以这么分：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glca3fn0auj31fy0u0gqn.jpg" alt="IMG_0265(20201205-001311)"></p>
<p>比较类排序就是通过元素之间的比较进行排序。</p>
<h2 id="一-冒泡排序-Bubble-Sort"><a href="#一-冒泡排序-Bubble-Sort" class="headerlink" title="一. 冒泡排序(Bubble Sort)"></a>一. 冒泡排序(Bubble Sort)</h2><p>把第一个元素与第二个元素比较，如果第一个比第二个大，则交换他们的位置。接着继续比较第二个与第三个元素，如果第二个比第三个大，则交换他们的位置….</p>
<p>我们对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样一趟比较交换下来之后，排在最右的元素就会是最大的数。</p>
<p>除去最右的元素，我们对剩余的元素做同样的工作，如此重复下去，直到排序完成。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmcvauk7xug30k0068tjv.gif" alt="img"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = size;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">    show(a,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序(优化算法)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = size;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line">    show(a,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用count来记录比较的次数，两次排序的结果：</p>
<blockquote>
<p>105<br> 2 3 4 5 15 19 26 27 36 38 44 46 47 48 50</p>
<p>95<br> 2 3 4 5 15 19 26 27 36 38 44 46 47 48 50</p>
</blockquote>
<p>优化的冒泡排序里，我们设置了一个flag，每次冒泡时我们都将flag置成0，而元素换位时，将flag置成1，当一次冒泡没有任何元素换位，也就是说这时候剩下的元素已经按照顺序排好了，我们就可以结束循环，结束排序，不必做重复比较的无用功了。</p>
<p><strong>性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、稳定排序  4、原地排序</strong></p>
<h2 id="二-选择排序-Selection-Sort"><a href="#二-选择排序-Selection-Sort" class="headerlink" title="二. 选择排序(Selection Sort)"></a>二. 选择排序(Selection Sort)</h2><p>在未排序的序列中，找到最小(大)的元素，然后将其与当前未排序的序列的最开始(最末尾)的位置元素进行交换，就是相当于每次在序列中选择一个最小或者最大的元素。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glcbjsvwtyj30k0064t8w.jpg" alt="img"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="comment">// 寻找最小元素的位置,并存储到minIndex中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;size<span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[minIndex])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素初始位置交换位置</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[minIndex];</span><br><span class="line">        a[minIndex] = a[i];</span><br><span class="line">        a[i] = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    show(a,<span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序</strong></p>
<p>解释一下为什么是非稳定排序，因为是直接换位置，可能某次选择时将原本在前面的元素调到了后面</p>
<h2 id="三-插入排序-Insertion-Sort"><a href="#三-插入排序-Insertion-Sort" class="headerlink" title="三. 插入排序(Insertion Sort)"></a>三. 插入排序(Insertion Sort)</h2><p>排序思路：将序列分为两个，一个已经排好序的，一个未排序的</p>
<p>排序过程：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glccaqjbk2j30k00cg74i.jpg" alt="img"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用cursor指示排好的序列的末尾，方便移动插入数据</span></span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="comment">// 用来临时储存要插入的元素</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line"></span><br><span class="line">        cursor = i<span class="number">-1</span>;</span><br><span class="line">        temp = a[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当cusor指示的数据要比要插入的数据小时，将当前元素的位置后移，也将cursor前移去比较</span></span><br><span class="line">        <span class="keyword">while</span>(cursor &gt;=<span class="number">0</span> &amp;&amp; a[cursor] &gt; temp)&#123;</span><br><span class="line">            a[cursor+<span class="number">1</span>] = a[cursor];</span><br><span class="line">            cursor--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//while循环以后，刚好当前cursor指示的元素比要插入的元素小，将待插入的元素插入位置</span></span><br><span class="line">        a[cursor+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    show(a,<span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>性质：1、时间复杂度：O(n2)  2、空间复杂度：O(1)  3、稳定排序  4、原地排序</strong></p>
<h2 id="四-希尔排序-Shell-Sort"><a href="#四-希尔排序-Shell-Sort" class="headerlink" title="四. 希尔排序(Shell Sort)"></a>四. 希尔排序(Shell Sort)</h2><p>希尔排序可以说是<strong>插入排序</strong>的一种变种。无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要 n - 1 次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。</p>
<p>希尔排序就是为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序。</p>
<p>希尔排序的思想是采用<strong>插入排序</strong>的方法，先让数组中任意间隔为 h 的元素有序，刚开始 h 的大小可以是 h = n / 2,接着让 h = n / 4，让 h 一直缩小，当 h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glcvabrniij30u00vatc3.jpg" alt="img"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> h, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start+h; i&lt;len; i+=h)&#123;</span><br><span class="line">        cursor = i-h;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        <span class="keyword">while</span>(cursor &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[cursor])&#123;</span><br><span class="line">            a[cursor+h] = a[cursor];</span><br><span class="line">            cursor -= h;</span><br><span class="line">        &#125;</span><br><span class="line">        a[cursor+h] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 确定每次插排时，每组相邻元素的间隔h</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h = len/<span class="number">2</span>; h &gt; <span class="number">0</span>; h/=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 依次对每组进行插排</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)&#123;</span><br><span class="line">            insert(a,i,h,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    show(a,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序</strong></p>
<h2 id="五-快速排序-Quick-Sort"><a href="#五-快速排序-Quick-Sort" class="headerlink" title="五. 快速排序(Quick Sort)"></a>五. 快速排序(Quick Sort)</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glcxxh6nsjj30k0068jrk.jpg" alt="img"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定中轴基准</span></span><br><span class="line">    <span class="keyword">int</span> pivot = a[left];</span><br><span class="line">    <span class="keyword">int</span> i = left+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 从左向右找到第一个比基准大的</span></span><br><span class="line">        <span class="keyword">while</span>( i&lt;=j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">        <span class="comment">// 从右向左找到第一个比基准小的</span></span><br><span class="line">        <span class="keyword">while</span>( j&gt;=i &amp;&amp; a[j] &gt;= pivot) j--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若位置i，j重叠，则终止循环</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i,j位置的值交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 容易知道在j迭代的结尾，j一定是到了i的位置，此时i位置的元素值一定要比pivot小，可以与基准交换位置</span></span><br><span class="line">    a[left] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> midth = partition(a,left,right);</span><br><span class="line">        <span class="comment">// 当只有一个元素时，这里的midth与left，right值是一样的，这也是为什么前面要套一个if，防止数组越界</span></span><br><span class="line">        QuickSort(a,left,midth<span class="number">-1</span>);</span><br><span class="line">        QuickSort(a,midth+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>性质：1、时间复杂度：(平均)O(nlogn)  2、空间复杂度：O(logn)  3、非稳定排序  4、原地排序</strong></p>
<p>有可能会出现一种极端的情况，每次分割的时候，主元左边的元素个数都为0，而右边都为n-1个。这个时候，就需要分割n次了。而每次分割整理的时间复杂度为O(n)，所以最坏的时间复杂度为O(n2)。</p>
<p>而最好的情况就是每次分割都能够从数组的中间分割了，这样分割logn次就行了，此时的时间复杂度为O(nlogn)。</p>
<p>而平均时间复杂度，则是假设每次主元等概率着落在数组的任意位置，最后算出来的时间复杂度为O(nlogn)，至于具体的计算过程，我就不展开了。</p>
<h2 id="六-归并排序-Merge-Sort"><a href="#六-归并排序-Merge-Sort" class="headerlink" title="六. 归并排序(Merge Sort)"></a>六. 归并排序(Merge Sort)</h2><p>将一个大的无序数组有序，我们可以把大的数组分成两个，然后对这两个数组分别进行排序，之后在把这两个数组合并成一个有序的数组。由于两个小的数组都是有序的，所以在合并的时候是很快的。</p>
<p>通过递归的方式将大的数组一直分割，直到数组的大小为 1，此时只有一个元素，那么该数组就是有序的了，之后再把两个数组大小为1的合并成一个大小为2的，再把两个大小为2的合并成4的 ….. 直到全部小的数组合并起来。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glczm0w0n6j30k00cg74i.jpg" alt="img"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> midth, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = midth+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= midth &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[j])&#123;</span><br><span class="line">            b[cursor] = a[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            b[cursor] = a[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=midth)&#123;</span><br><span class="line">        b[cursor] = a[i];</span><br><span class="line">        i++; cursor++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)&#123;</span><br><span class="line">        b[cursor] = a[j];</span><br><span class="line">        j++; cursor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = left, m = <span class="number">0</span>; x&lt;=right; m++,x++)&#123;</span><br><span class="line">        a[x] = b[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> midth = (right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 这里将数组分成两个部分，不是乱分的，必须要把midth放到前一个，而midth+1放到下一个</span></span><br><span class="line">        <span class="comment">// 由于这里的递归出口是left == right</span></span><br><span class="line">        <span class="comment">// 而如果不是midth+1，我们永远也得不到midth == right</span></span><br><span class="line">        MergeSort(a,left,midth);</span><br><span class="line">        MergeSort(a,midth+<span class="number">1</span>,right);</span><br><span class="line">        merge(a,left,midth,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(n)  3、稳定排序  4、非原地排序</strong></p>
<h2 id="七-堆排序-Heap-Sort"><a href="#七-堆排序-Heap-Sort" class="headerlink" title="七. 堆排序(Heap Sort)"></a>七. 堆排序(Heap Sort)</h2><p>堆的特点就是堆顶的元素是一个<strong>最值</strong>，大顶堆的堆顶是最大值，小顶堆则是最小值。</p>
<p>堆排序就是把堆顶的元素与最后一个元素交换，交换之后破坏了堆的特性，我们再把堆中剩余的元素再次构成一个大顶堆，然后再把堆顶元素与最后第二个元素交换….如此往复下去，等到剩余的元素只有一个的时候，此时的数组就是有序的了。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld4ui8fq9j30u016kgy0.jpg" alt="草稿本-57"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld4utxrj4j30u016kwls.jpg" alt="草稿本-58"></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld4v7ghr8j30u016kqek.jpg" alt="草稿本-56"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> len, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= len) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> c1 = <span class="number">2</span>*n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c2 = <span class="number">2</span>*n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> max = n;</span><br><span class="line">    <span class="keyword">if</span>(c1 &lt; len &amp;&amp; a[c1] &gt; a[max])&#123;</span><br><span class="line">        max = c1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c2 &lt; len &amp;&amp; a[c2] &gt; a[max])&#123;</span><br><span class="line">        max = c2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max != n)&#123;</span><br><span class="line">        swap(a,n,max);</span><br><span class="line">        heapify(a,len,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (len<span class="number">-1</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(a,len,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    build_heap(a,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        swap(a,<span class="number">0</span>,i);</span><br><span class="line">        build_heap(a,i);</span><br><span class="line">        show(a,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>性质：1、时间复杂度：O(nlogn)  2、空间复杂度：O(1)  3、非稳定排序  4、原地排序</strong></p>
<h2 id="八-计数排序-Counting-Sort"><a href="#八-计数排序-Counting-Sort" class="headerlink" title="八. 计数排序(Counting Sort)"></a>八. 计数排序(Counting Sort)</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld69a0fiog30k00b0tbf.gif" alt="img"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CountingSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录最大元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; max) max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得计数数组</span></span><br><span class="line">    <span class="keyword">int</span> b[max+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;max+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        b[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数数组开始计数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">        b[a[j]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取计数数组里位置上不为0的位置，重复读取直至为零</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=max; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = b[i]; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">            a[k++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    show(a,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(k)  3、稳定排序  4、非原地排序</strong></p>
<h2 id="九-桶排序-Bucket-Sort"><a href="#九-桶排序-Bucket-Sort" class="headerlink" title="九. 桶排序(Bucket Sort)"></a>九. 桶排序(Bucket Sort)</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。</p>
<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld81vzudbj30c408agls.jpg" alt="img"></p>
<p><strong>性质：1、时间复杂度：O(n+k)  2、空间复杂度：O(n+k)  3、稳定排序  4、非原地排序</strong></p>
<h2 id="十-基数排序-Radix-Sort"><a href="#十-基数排序-Radix-Sort" class="headerlink" title="十. 基数排序(Radix Sort)"></a>十. 基数排序(Radix Sort)</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gld81er2olg30k00bc0z1.gif" alt="img"></p>
<p><strong>性质：1、时间复杂度：O(kn)  2、空间复杂度：O(n+k)  3、稳定排序  4、非原地排序</strong></p>
<p>太多了，写不下去了</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c语言</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>git简介</title>
    <url>/2020/12/10/git%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="1-什么是git？"><a href="#1-什么是git？" class="headerlink" title="1.什么是git？"></a>1.什么是git？</h1><p>git是一个分布式的版本控制工具，git的设计简单，是完全分布式的，允许成千上万的并行开发的分支（branch），有能力管理超大规模的项目，是首选的版本控制工具。</p>
<ul>
<li>版本控制：一种记录一个或者若干文件内容的变化，以便查阅特定的版本修订情况的系统</li>
<li>分布式版本控制系统：把代码仓库完整的镜像下来，包括完整的历史记录。每一次克隆操作实际上都是一次对代码仓库的完整备份</li>
</ul>
<p>当我们在使用git来管理我们的代码时，就可以很轻易的回溯到我们任意时间点所做的修改和提交，由于git的特性，我们可以很轻易就可以看到自己的修改，同时还可以利用分支管理在相同的时间做并行开发</p>
<a id="more"></a>

<h1 id="2-初次运行git前的配置"><a href="#2-初次运行git前的配置" class="headerlink" title="2.初次运行git前的配置"></a>2.初次运行git前的配置</h1><p>git自带一个git config工具可以用来帮助我们控制git的外观和行为的配置变量，一般来说，这些变量储存在三个位置上：</p>
<ol>
<li>/etc/gitconfig文件：包含系统上每一个用户以及他们仓库的通用配置，如果在执行git config上加上–system选项，那么修改的就是这个文件的配置变量，这个的作用范围最广</li>
<li>～/.gitconfig:只针对电脑的当前用户。可以传递–global参数来修改这个文件里的配置变量</li>
<li>当前使用的git仓库里的.git会有一个config文件：这个只针对该仓库，可以传递–local选项修改，默认也是这个</li>
</ol>
<p>每一个级别会覆盖上一个级别的配置，也就是说你给某个git仓库的user.name修改后，上面的两个gitconfig的相应配置变量就对这个git仓库无效了</p>
<p>可以使用 <code>git config --list --show-origin</code>查看所有的配置以及他们所在的文件</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli3to5yt4j314g03mwf9.jpg" alt="屏幕快照 2020-12-10 上午1.11.41"></p>
<p>这个是我的所有git目录，当然我不是在某个git仓库里执行的命令,所以找不到第三个gitconfig，而我们进入一个git目录就会发现：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli3x2idrmj314u0ay76o.jpg" alt="屏幕快照 2020-12-10 上午1.14.54"></p>
<p>内容会多出一些，关于仓库的远程连接，一般在安装好git以后，我们只需要执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;your username&quot;</span><br><span class="line">git config --global user.email yourEmail</span><br></pre></td></tr></table></figure>

<p>把自己的用户信息写进gitconfig里，这样，当我们在git仓库里做修改或着提交时候就知道你的信息了</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli413hr5dj317e0gujtn.jpg" alt="屏幕快照 2020-12-10 上午1.18.34"></p>
<p>​    比如这几个提交，我们就可以轻易的知道来自于哪里了</p>
<h1 id="3-git的工作流程"><a href="#3-git的工作流程" class="headerlink" title="3.git的工作流程"></a>3.git的工作流程</h1><p>git的三个工作区域对应着三个工作状态：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli45heht1j33340mmq9s.jpg" alt="6A5682E0F6FBFF11C78ADA00C48A2B3F"></p>
<p>工作流程：</p>
<ol>
<li>在工作目录里修改文件（modified）；<ol>
<li>我们在工作区修改了文件，而没有用git add加入到暂存区时，就是modified</li>
</ol>
</li>
<li>暂存文件，将文件快照放入暂存区（staged）；<ol>
<li>使用git add添加以后，就变成了staged</li>
</ol>
</li>
<li>提交更新，找到暂存区的工作文件，将文件永久的存储到git的仓库目录里（committed）</li>
</ol>
<p>git关于本地文件的状态：</p>
<p>编辑某些文件以后，由于自上次的提交后，你对他们做了修改，git将他们标记为已修改文件。在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已经暂存的修改，如此反复：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glljf3ubkfj318f0hjaee.jpg" alt="IMG_125B9A301149-1"></p>
<h1 id="4-git的简单使用"><a href="#4-git的简单使用" class="headerlink" title="4.git的简单使用"></a>4.git的简单使用</h1><ul>
<li><p>git init 初始化一个空的git仓库，这时候相应的文件夹下会自动生成.git的文件夹，里面就有刚刚说的gitconfig</p>
</li>
<li><p>git status:查看文件的工作状态</p>
</li>
<li><p>git add 跟踪文件，运行</p>
<ul>
<li>此时被add的文件已经被跟踪，处于暂存的状态，显示为changes to be committed</li>
</ul>
</li>
<li><p>git commit -m “提交所做的注解” 提交更新到仓库</p>
</li>
<li><p>git diff:显示暂未暂存的改动，并非所有改动</p>
</li>
<li><p>git rm 文件名：删除掉暂存区的文件,一般加上后缀–cached表示不删除原文件，只是从git暂存区删除，而-f则是直接删除掉这个文件</p>
</li>
<li><p>git log:查看提交的历史，可以查看一个项目提交历史的各个人的提交</p>
</li>
<li><p>版本回退：在git log里可以看到 commit后面跟着的这一大串散列码，这就是git的版本号，我们可以使用git reset –hard 版本号回退到之前的任何一个版本（本地是reset，远程是revert）</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli4ydr3pzj30u00ufdlq.jpg" alt="屏幕快照 2020-12-10 上午1.50.46"></p>
</li>
</ul>
<h1 id="5-关于忽略文件-gitignore"><a href="#5-关于忽略文件-gitignore" class="headerlink" title="5.关于忽略文件.gitignore"></a>5.关于忽略文件.gitignore</h1><p>有时候会有一些文件无需要纳入git管理，通常是一些自动生成的文件，比如.exe或者一些日志文件，这种情况下我们可以创建一个名为.gitignore文件</p>
<p>例如：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glljwvkko2j30dy0i4wfq.jpg" alt="屏幕快照 2020-12-13 上午12.44.50"></p>
<p>倒数第二行意思就是git忽略所有.o或者.a结尾的文件，一般这类文件都是在编译过程中出现的，最后一行就时忽略所有～结尾的文件。</p>
<p>最简单的情况下，一个仓库可能只有根目录下有一个.gitignore文件，会递归的调用到整个仓库中，而当子目录下也有额外的.gitignore文件。子目录中的.gitignore文件的规则只作用于它所在的目录。</p>
<p>文件.gitignore的格式规范如下：</p>
<ol>
<li>所有空行和#开头的行都被视为注释而忽略掉</li>
<li>使用标准的glob模式匹配，会递归的调用到整个文件区（？）</li>
<li>匹配模式可以以（/）开头防止递归</li>
<li>匹配模式可以以（/）结尾指定目录</li>
<li>要忽略指定模式以外的文件或者目录，可以在模式前加！取反</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gllk9eypvij31210jt42i.jpg" alt="IMG_7193A70E1EED-1"></p>
<p>关于glob模式：</p>
<p>一种在shell里简化了的正则表达式，用*等匹配模式来匹配文件，在解析路径模式时，大括号内用逗号进行分割，分割的部分可以包含/，所以a{/b/c,bcd}会被展开为a/b/c和abcd</p>
<p>在路径匹配模式里，以下字符有一些特殊的作用：</p>
<ul>
<li><p>*：匹配单路径下0个或者多个字符串</p>
</li>
<li><p>？：匹配一个字符串</p>
</li>
<li><p>[…]：匹配指定范围内的字符串，如果[]中第一个字符是！或者^ ，则匹配不在范围内的任意字符串</p>
</li>
</ul>
<p>知道这么多差不多够用了</p>
<h1 id="6-git的分支管理"><a href="#6-git的分支管理" class="headerlink" title="6.git的分支管理"></a>6.git的分支管理</h1><h2 id="1-分支的简单图解"><a href="#1-分支的简单图解" class="headerlink" title="1.分支的简单图解"></a>1.分支的简单图解</h2><p>在版本回退里，我们可以回溯到之前的任意一个版本里，而这些版本都处在一条时间线上，这条时间线就是一条分支</p>
<p>默认的分支是main（之前是master，后来由于这个词有歧视黑人的意思，就换了这里的图都是用的master），本身可以把它看成一个指针，head指针就是一个特殊的指针，这里就指向master指针</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli5672o9lj308d0473yf.jpg" alt="image-20201210015840577"></p>
<p>我们在每次提交的时候，都会多出一个节点，指针也会随之移动，当我们创建一个新的分支，也就是创建一个新的指针，我们可以通过命令将head指针移动到新的指针上：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli58b6b3mj30dq06h3yj.jpg" alt="image-20201210020044381"></p>
<p>我们还可以将两个分支合并：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli5a76lkcj30br066jre.jpg" alt="image-20201210020232237"></p>
<p>还可以在这里把dev分支给删掉</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gli5awchx8j30br04fwef.jpg" alt="image-20201210020314110"></p>
<h2 id="2-分支的使用"><a href="#2-分支的使用" class="headerlink" title="2.分支的使用"></a>2.分支的使用</h2><ol>
<li>git branch 查看当前所有分支，及所在分支</li>
<li>git branch 分支名 ：创建新的分支</li>
<li>git checkout 分支名：切换到别的分支</li>
<li>（处于某个分支下）git merge 分支名，这就是将两个分支合并，此时两个分支就处在同一个节点下</li>
<li>git branch -d ：删除分支</li>
</ol>
<h1 id="7-关于git远程仓库的使用"><a href="#7-关于git远程仓库的使用" class="headerlink" title="7.关于git远程仓库的使用"></a>7.关于git远程仓库的使用</h1><h2 id="仓库服务器"><a href="#仓库服务器" class="headerlink" title="仓库服务器"></a>仓库服务器</h2><p>如果想查看你已经配置的远程仓库的服务器，可以运行<code>git remote</code>命令，会列出你的远程服务器的简写，一般来说链接了远程仓库，至少能够看到origin，这是给你克隆的仓库服务器的默认名字，也可以指定选项-v，会显示需要读写远程仓库使用的git保存的简写与其对应的url</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gllkyky485j30qo07adgr.jpg" alt="屏幕快照 2020-12-13 上午1.21.19"></p>
<h2 id="添加远程仓库："><a href="#添加远程仓库：" class="headerlink" title="添加远程仓库："></a>添加远程仓库：</h2><p>可以使用git clone自动自行添加远程仓库的，也可以自行配置，比如：</p>
<p><code>git remote add &lt;shortname&gt; &lt;url&gt;</code>:添加一个新的远程git仓库，同时指定一个方便实用的简写</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glllgrj6rlj314a0qpgw0.jpg" alt="IMG_6B07EE8387AE-1"></p>
<p>果你想要查看它，可以剪出一个指向改点的本地分支</p>
<h2 id="从远程仓库中抓取和拉取："><a href="#从远程仓库中抓取和拉取：" class="headerlink" title="从远程仓库中抓取和拉取："></a>从远程仓库中抓取和拉取：</h2><p>git fetch  &lt; remote&gt; 会将远程的仓库的数据下载到本地仓库，但不会自动合并并修改当前的工作，需要手动合并，如果当前分支设置了跟踪的远程分支，可以使用git pull自动抓取远程分支的数据合并到本地</p>
<h2 id="推送到远程分支："><a href="#推送到远程分支：" class="headerlink" title="推送到远程分支："></a>推送到远程分支：</h2><p>git push &lt; remote&gt; &lt; branch&gt;,如果要将master分支推送到origin服务器，那么就可以运行<code>git push origin master</code></p>
<p>比如第一次对远程仓库进行操作，使本地与github同步</p>
<blockquote>
<p>git remote add origin +git地址 (添加远程仓库到本地)</p>
<p>git pull –rebase origin main(更新远程仓库的更新（mian分支)到本地）</p>
<p>git push -u origin main将本地仓库与远程合并</p>
</blockquote>
<h1 id="8-git-与github的多人协作"><a href="#8-git-与github的多人协作" class="headerlink" title="8.git 与github的多人协作"></a>8.git 与github的多人协作</h1><p>在一个github的仓库里，我们一般会有一个主分支，会有许多许多开发分支，每个人可以自己拉取一个分支，也可以都在一个分支里开发，开发者单独在这样的分支里开发自己的代码和功能，最后提交到拉取的分支上，最后再pull request一下，等待确认无误，再merge到主分支上，这就是一个规范的多人协作开发的流程。</p>
<p>将项目克隆到本地打开以后，在本地的仓库里建立新分支并连接远程分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b dev origin&#x2F;dev</span><br></pre></td></tr></table></figure>

<p>之后就可以在本地的dev分支进行提交（add, commit, push)，可能会出现提交不成功，应该是因为远程分支的版本比本地的更新，这个时候只需要git pull一下，将远程更新拉取到本地就行，这里可能出现的问题有两种：</p>
<ol>
<li><p>如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmxvej76dvj30zg0b63zs.jpg" alt="屏幕快照 2021-01-23 下午7.49.34">只需要在按提示在命令行输入 gi t branch –set-upstream-to=origin/dev dev 就可以，这样会把本地的dev分支追踪到远程仓库的dev分支</p>
</li>
<li><p>注意这个时候也有可能会出现冲突，可以使用git status查看那些文件有问题，进入文件查看几个相应的地方出现的&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; =========&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;这样的东西，删掉冲突的地方再add就可以了</p>
</li>
</ol>
<p>完毕后，我们就将自己在本地dev上的更改提交到了github的远程仓库上，这个时候只需要在github上提交一个pull request，注意是在dev分支向main分支上提pull request，就完成自己的提交任务。</p>
<p>在项目开发的过程中，可能会有其他的人的提交被main分支merge上了，我们需要在本地切换到main分支上，git pull一下，同步更新，之后再进入dev分支，也要调用git merge origin/main 合并主分支上的最新更新，如果有冲突，就像前面那样处理冲突，在就可以git add 等，最后git merge -continue</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android本地数据库-Room</title>
    <url>/2020/12/18/Android%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%BA%93-Room/</url>
    <content><![CDATA[<h1 id="Room介绍"><a href="#Room介绍" class="headerlink" title="Room介绍"></a>Room介绍</h1><p>Room 在 SQLite 上提供了一个抽象层，以便在充分利用 SQLite 的强大功能的同时，能够流畅地访问数据库。处理大量结构化数据的应用可极大地受益于在本地保留这些数据。最常见的用例是缓存相关数据。这样，当设备无法访问网络时，用户仍可在离线状态下浏览相应内容。设备重新连接到网络后，用户发起的所有内容更改都会同步到服务器。</p>
<p>SQLite是一个软件库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。SQLite 可在 UNIX（Linux, Mac OS, Android, iOS）和 Windows（Win32）中运行。</p>
<a id="more"></a>

<p>具体的数据库一般是什么样呢，其实数据库就主要是有各种表组成，最后在表里面进行增删查改，实行数据的获取和删除等功能，那表一般来说就是这样的：</p>
<table>
<thead>
<tr>
<th>学生表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>学号</td>
<td>姓名</td>
<td>年龄</td>
</tr>
<tr>
<td>S001</td>
<td>张三</td>
<td>24</td>
</tr>
<tr>
<td>S002</td>
<td>李四</td>
<td>25</td>
</tr>
<tr>
<td>S003</td>
<td>王二麻子</td>
<td>26</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>课程表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>课程号</td>
<td>课程名</td>
<td>学分</td>
</tr>
<tr>
<td>C001</td>
<td>Linux</td>
<td>25</td>
</tr>
<tr>
<td>C002</td>
<td>Python</td>
<td>25</td>
</tr>
<tr>
<td>C003</td>
<td>MySQL</td>
<td>25</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>选课表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>学号</td>
<td>课程号</td>
<td>成绩</td>
</tr>
<tr>
<td>S001</td>
<td>C001</td>
<td>90</td>
</tr>
<tr>
<td>S002</td>
<td>C001</td>
<td>97</td>
</tr>
<tr>
<td>S003</td>
<td>C001</td>
<td>94</td>
</tr>
</tbody></table>
<p>Room 包含 3 个主要组件：</p>
<ul>
<li><p>数据库：包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。</p>
<p>使用 @Database注释的类应满足以下条件：</p>
<ul>
<li>是扩展 RoomDatabase 的抽象类。</li>
<li>在注释中添加与数据库关联的实体列表。</li>
<li>包含具有 0 个参数且返回使用 @Dao注释的类的抽象方法。</li>
</ul>
<p>在运行时，您可以通过调用 Room.databaseBuilder() 或Room.inMemoryDatabaseBuilder()获取 Database 的实例。</p>
</li>
</ul>
<ul>
<li><p>Entity：表示数据库中的表。</p>
</li>
<li><p>DAO：包含用于访问数据库的方法。</p>
</li>
</ul>
<p>应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gltmqa0tsjj30go0f2dgo.jpg" alt="img"></p>
<h2 id="一、添加依赖"><a href="#一、添加依赖" class="headerlink" title="一、添加依赖"></a>一、添加依赖</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  def room_version = <span class="string">&quot;2.2.5&quot;</span></span><br><span class="line"></span><br><span class="line">  implementation <span class="string">&quot;androidx.room:room-runtime:$room_version&quot;</span></span><br><span class="line">  annotationProcessor <span class="string">&quot;androidx.room:room-compiler:$room_version&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - RxJava support for Room</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.room:room-rxjava2:$room_version&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Guava support for Room, including Optional and ListenableFuture</span></span><br><span class="line">  implementation <span class="string">&quot;androidx.room:room-guava:$room_version&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional - Test helpers</span></span><br><span class="line">  testImplementation <span class="string">&quot;androidx.room:room-testing:$room_version&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、编写Entity类（这个类就是去包装具体的数据）"><a href="#二、编写Entity类（这个类就是去包装具体的数据）" class="headerlink" title="二、编写Entity类（这个类就是去包装具体的数据）"></a>二、编写Entity类（这个类就是去包装具体的数据）</h2><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = &quot;word_table&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrimaryKey</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = &quot;word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mWord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Word</span><span class="params">(String mWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mWord = mWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面已经说过了，要写一个room作为本地数据库，对于安卓来说其实只需要将Entity、Dao、Database写好就可以，自利用这些类去实现数据库的增删查改。</p>
<p>对于我们一个数据想要存储的数据，我们一般要将这个储存的数据设为public或者要有一个get方法，方看去读取内容</p>
<p>这里解释一下具体的注解的作用：</p>
<p>@Entity就是在检查这个类去作为一个数据项，一般默认类名就是表名，但是这里可以在注解里写上<code>tableName = &quot;xxx&quot;</code>，就可以自己为这个表去命名。SQLite中的表名不区分大小写。</p>
<p>@PrimaryKey就是主键，惟一地标识一行(一张表中只能有一个主键)<br>主键应当是对用户没有意义的（常用于索引）<br>永远不要更新主键，否则违反对用户没有意义原则<br>主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等</p>
<p>比如：</p>
<table>
<thead>
<tr>
<th>学生表</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>学号</td>
<td>姓名</td>
<td>年龄</td>
</tr>
<tr>
<td>S001</td>
<td>张三</td>
<td>24</td>
</tr>
<tr>
<td>S002</td>
<td>李四</td>
<td>25</td>
</tr>
<tr>
<td>S003</td>
<td>王二麻子</td>
<td>26</td>
</tr>
</tbody></table>
<p>在这样一个数据表里，学号就可以作为主键，我们可以用主键实行数据的查找，而且学号是唯一的，是不能修改的，而这个表的tableName就是学生表</p>
<p>@ColumnInfo就表示这个表的一个列，比如上面的表里就有学号，姓名，年龄等等</p>
<p>在这里就可以看到，我们通过编写Entity类就可以为这个表搭建一个模版，规定表中的数据有哪些类型，而具体的这个Entity的对象就可以动态的把数据设置到对象的属性里，在room里就相当于放到这个表里了</p>
<h2 id="三、编写Dao类"><a href="#三、编写Dao类" class="headerlink" title="三、编写Dao类"></a>三、编写Dao类</h2><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WordDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">// allowing the insert of the same word multiple times by passing a</span></span><br><span class="line">    <span class="comment">// conflict resolution strategy</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.IGNORE)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Word word)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;DELETE FROM word_table&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT * FROM word_table ORDER BY word ASC&quot;)</span></span><br><span class="line">    LiveData&lt;List&lt;Word&gt;&gt; getAlphabetizedWords();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>DAO既可以是接口，也可以是抽象类。如果是抽象类，它可以有一个构造函数，它把<code>RoomDatabase</code>作为唯一的参数。Room在编译时创建每个DAO实现。至于为什么DAO要是一个抽象类或接口，我自己的看法就是，这个dao是用来干什么的呢，无非就是帮助我们对数据库进行增删查改的，那它里面就是要封装好一套方法，且对于数据库来说它就是工具包一样的，我的所有操作都有他来帮助实现，在写database事的时候，将接口或者抽象类的方法放进来就很方便，从他功能的角度就可以理解，他没有建一个对象的必要</p>
</li>
<li><p>像定义Entity一样，在Dao的定义的前一行，加上注解**@Dao**即可。</p>
</li>
<li><p><strong>Dao下的所有方法，都有一个注解</strong>。不同的注解，代表不同的意思，比如增删查改。而这些SQL语句是否合法，会在编译阶段就先过滤。如果你的SQL语句写错了，那将会编译失败。</p>
</li>
</ol>
<p><code>@Delete</code>: 便捷方法会从数据库中删除一组以参数形式给出的实体。它使用主键查找要删除的实体。</p>
<p>以下代码段演示了如何定义此方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDao</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Delete</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteWord</span><span class="params">(Word word)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>@Query</code>是 DAO 类中使用的主要注释。它允许您对数据库执行读/写操作。每个 <code>@Query</code>方法都会在编译时进行验证，因此如果查询出现问题，则会发生编译错误，而不是运行时失败。</p>
<p>Room 还会验证查询的返回值，以确保当返回的对象中的字段名称与查询响应中的对应列名称不匹配时，Room 可以通过以下两种方式之一提醒您：</p>
<ul>
<li>如果只有部分字段名称匹配，则会发出警告。</li>
<li>如果没有任何字段名称匹配，则会发出错误。</li>
</ul>
<p>像这些注解里面写的是sql语句，就是数据库一套专门操作语言，有兴趣可以去看看，一般要实现什么功能就可以去查查</p>
<h2 id="四、编写Database类（继承自RoomDatabase）"><a href="#四、编写Database类（继承自RoomDatabase）" class="headerlink" title="四、编写Database类（继承自RoomDatabase）"></a>四、编写Database类（继承自RoomDatabase）</h2><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = &#123;Word.class&#125;,version = 1,exportSchema = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WordRoomDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> WordDao <span class="title">wordDao</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> WordRoomDatabase INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_OF_THREADS = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService databaseWriteExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(NUMBER_OF_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> WordRoomDatabase <span class="title">getDatabase</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (WordRoomDatabase.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),</span><br><span class="line">                            WordRoomDatabase.class, <span class="string">&quot;word_database&quot;</span>)</span><br><span class="line">                            .build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个类写完以后，我们的一个简单的数据库就写完了，看这里的第一行注解，@Database后面的东西，这里是不是指明了entity是什么东西，这里传进去一个类对象，这样数据库就规定类他的框架，它里面能放什么，放什么样的东西，有什么限制都遵从这个Word这个类里的规范，version就是这个数据库的版本，当我们要对数据库进行更新的时候可能要用，这里不讨论，后面的表示数据库是不能通过迁移实现，不管这些。</p>
<p>再看这里有接口，wordDao()就是我们之前写的给数据库的操作写好的方法，就可以在数据库里用接口里的方法实现数据库的操作。</p>
<p>后面是一些多线程相关的东西，synchronized就是一个获得线程锁的机制，这样就会导致每次在执行代码块里里语句修改内存时，只有一个县线程可以修改，在这线程执行完才可以去执行别的线程的相关代码。</p>
<p>volatile可以实现变量的可见性，就是说一旦某个线程修改了volatile关键字修饰的变量，则该变量将会立即保存修改后的值到物理内存中，其他线程读取该变量时，也可以立即获取修改后的值。<br> 在java运行中，为了提高程序的运行效率，对于一些变量的操作通常是在寄存器或者cpu缓存上进行的，之后才会保存到物理内存中，而使用volatile关键字修饰的变量则是直接读取物理内存。</p>
<p>一般来说创建一个数据库是十分耗费资源的，所以我们一般是使用单例模式，去实现一个标准的数据库，可以看这个代码两块静态代码实现了单例模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Room.databaseBuilder(context.getApplicationContext(),</span><br><span class="line">                            WordRoomDatabase.class, <span class="string">&quot;word_database&quot;</span>)</span><br><span class="line">                            .build();</span><br></pre></td></tr></table></figure>

<p>这就是创建database的核心代码，具体怎么实现android已经帮你实现好了，我们直接穿参数进去就好了</p>
<h2 id="五、具体使用"><a href="#五、具体使用" class="headerlink" title="五、具体使用"></a>五、具体使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WordDao mWordDao;</span><br><span class="line">    <span class="keyword">private</span> LiveData&lt;List&lt;Word&gt;&gt; mAllWords;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    WordRepository(Application application) &#123;</span><br><span class="line">        WordRoomDatabase db = WordRoomDatabase.getDatabase(application);</span><br><span class="line">        mWordDao = db.wordDao();</span><br><span class="line">        mAllWords = mWordDao.getAlphabetizedWords();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LiveData&lt;List&lt;Word&gt;&gt; getAllWords() &#123;</span><br><span class="line">        <span class="keyword">return</span> mAllWords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You must call this on a non-UI thread or your app will throw an exception. Room ensures</span></span><br><span class="line">    <span class="comment">// that you&#x27;re not doing any long running operations on the main thread, blocking the UI.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Word word)</span> </span>&#123;</span><br><span class="line">        WordRoomDatabase.databaseWriteExecutor.execute(() -&gt; &#123;</span><br><span class="line">            mWordDao.insert(word);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们通过一个WordRepository将数据库中的所有数据获得，且交代了各种操作方法，我们要进行各种操作只需要实例化一个这个类的对象就可以了。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-JVM</title>
    <url>/2021/03/19/Java-JVM/</url>
    <content><![CDATA[<h1 id="一、什么是JVM？"><a href="#一、什么是JVM？" class="headerlink" title="一、什么是JVM？"></a>一、什么是JVM？</h1><h2 id="1-从jdk说起"><a href="#1-从jdk说起" class="headerlink" title="1. 从jdk说起"></a>1. 从jdk说起</h2><p>在初次运行Java代码之前我们都要下载一个叫做jdk的东西，并且要配置好环境变量，这样我们的java代码才能跑起来，达到我们想要的效果。简单的说，jdk就是用于支持java程序开发的最小环境，主要由Java程序设计语言、Java虚拟机、Java类库组成。jdk是java的核心，包含JRE和一些java工具（比如javac，java，jdb等）以及java的基础类库。</p>
<p>JRE叫做Java运行时环境，在jdk的安装目录下，里面又有bin和lib两个文件夹，可以简单地理解成bin里面的就是jvm，而这个lib里装的是JVM工作时所需要的类库。</p>
<a id="more"></a>

<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqerxazlnj30im0bdjr9.jpg"></p>
<h2 id="2-JVM的作用和好处"><a href="#2-JVM的作用和好处" class="headerlink" title="2.JVM的作用和好处"></a>2.JVM的作用和好处</h2><p>JVM是java能实现跨平台开发的核心，在一开始推出java的时候，开发者打出的口号是“一次编译，到处执行”，而能够实现这一目标的根源就是JVM，所有的Java程序在编译器编译过后，首先会编译成一个.class文件，这种类文件就会在虚拟机中解释运行，再通过虚拟机将程序解释给操作系统去执行，这样在不同的操作系统上我们只需要安装不同的虚拟机就可以运行同样的一份编译好的java程序。</p>
<p>java不像c++、c语言那样编译后直接与操作系统联系，跑在我们的电脑上，而是根据一个叫做java虚拟机的东西，用它来解释我们编译好的java代码，生成相应的机器语言，交由操作系统执行，从而运行程序。</p>
<h1 id="二、JVM的自动内存管理"><a href="#二、JVM的自动内存管理" class="headerlink" title="二、JVM的自动内存管理"></a>二、JVM的自动内存管理</h1><p>我们在编写c、c++程序的时候，所有关于动态分配的内存，都需要我们在程序结束之前将其销毁掉，否则就可能会出现相应的内存泄漏。而对于java来说，在虚拟机自动内存管理机制的帮助下，不需要再为每一个new操作去配对相应的delete代码，这样就大大减少我们的工作量以及避免了大多数内存泄漏和溢出方面的问题。</p>
<h2 id="1-JVM运行时数据区域"><a href="#1-JVM运行时数据区域" class="headerlink" title="1. JVM运行时数据区域"></a>1. JVM运行时数据区域</h2><blockquote>
<p>Java虚拟机在执行java程序中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些则是依赖于用户的启动和结束而建立和销毁，Java虚拟机所管理的内存主要包括以下几个运行时数据区域：</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqeui77gmj30fx08ojs5.jpg"></p>
<h2 id="2-程序计数器（Program-Counter-Register）"><a href="#2-程序计数器（Program-Counter-Register）" class="headerlink" title="2. 程序计数器（Program Counter Register）"></a>2. 程序计数器（Program Counter Register）</h2><p>程序计数器时一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在字节码解释器工作时就是通过改变这个计数器的值来选取下一条要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都是要依赖这个计数器来完成。</p>
<p>比如，Java虚拟机的多线程就是通过线程轮流切换、分配处理器的执行时间的方式来实现的，在任何一个确定的时刻，一个单核处理器都只会执行一条线程中的一个指令。而程序计数器是为了指示下一条字节码指令在哪里，为了在线程切换以后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程的之间的计数器互不影响，独立储存。这类的内存区域我们称为“线程私有的”。</p>
<p>注意：当正在执行的是本地方法（native），这个计数器的值此时为null</p>
<h2 id="3-Java虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#3-Java虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="3.Java虚拟机栈（Java Virtual Machine Stack）"></a>3.Java虚拟机栈（Java Virtual Machine Stack）</h2><p>和程序计数器一样，栈也是线程私有的，生命周期和线程相同。java栈描述的是java方法执行的线程内存模型：每个方法被执行的时候就会先创建一个栈帧并放入虚拟机栈中，在方法执行完毕时再从虚拟机栈中移除该栈帧。什么是栈帧？它主要用来存储局部变量表、操作数栈、动态链接、方法出口等信息。方法在执行时就会有各种存储信息入栈出栈，一个栈帧就包含了一个java方法的执行的所有信息。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用（reference）和returnAddress类型，局部变量表所需的内存空间在编译期完成分配，在方法运行期不会改变局部变量表的大小。在JVM规范中并没有对虚拟机栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。但是在规范中定义了两种异常情况：</p>
<ul>
<li>如果计算时请求的栈空间大于虚拟机栈的最大值，则会抛出<code>StackOverflowError</code>异常；</li>
<li>如果虚拟机栈设置为可扩展的并且无法再获取更多内存时，则会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h2 id="4-本地方法栈（Native-Stack-Stacks）"><a href="#4-本地方法栈（Native-Stack-Stacks）" class="headerlink" title="4.本地方法栈（Native Stack Stacks）"></a>4.本地方法栈（Native Stack Stacks）</h2><p>本地方法栈与虚拟机栈发挥的作用是非常相似的，其区别就是这里执行的是native方法，而虚拟机栈里执行的是java方法，在一些虚拟机中，比如Hot-Spot，本地方法栈和虚拟机栈是放到一起的，他们的相似性可见一斑。</p>
<h2 id="5-Java堆（Java-Heap）"><a href="#5-Java堆（Java-Heap）" class="headerlink" title="5. Java堆（Java Heap）"></a>5. Java堆（Java Heap）</h2><p>对于java程序来说，堆是虚拟机所管理的内存的最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例，Java世界里所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集管理的内存区域，从分配内存的角度来看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配的效率，但是原则上来说，Java堆里面对象是杂乱无章的，Java堆被细分的目的是为了更好的回收内存，或者更快的分配内存。Java堆是可以被实现成固定大小的，也是可以扩展的。但不管是何种方式，规范中还是定义了一种异常场景：</p>
<ul>
<li>如果计算需要更多的堆空间而无法满足时，则会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqh72zmtfj30oe0engmf.jpg"></p>
<h2 id="6-方法区（Method-Area）"><a href="#6-方法区（Method-Area）" class="headerlink" title="6.方法区（Method Area）"></a>6.方法区（Method Area）</h2><ol>
<li><p>方法区又被称为静态区，是程序中永远唯一的元素存储区域。和堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息（类的方法代码，变量名，方法名，访问权限，返回值等）、常量、静态变量、即时编译器编译后的代码等数据。            </p>
</li>
<li><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。<br> 这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。</p>
</li>
<li><p>很多开发者更愿意把方法区称为“永久代”(Permanent Generation)「总是存放不会轻易改变的内容」。在目前已经发布的JDK 1.7 的HotSpot中，已经把原本放在永久代的字符串常量池移至堆中。</p>
</li>
<li><p>运行时常量池(Runtime Constant Pool)是方法区的一部分。（对于普通常量池有一个重要特征就是具备动态性，Java并不制定常量只能在编译期才能产生，运行时可以将新的常量放入池中。</p>
<ol>
<li>Eg:<code>String.intern()</code>是一个Native(本地)方法，它的作用是如果字符串常量池已经包含一个等于此String对象的字符串，则返回字符串常量池中这个字符串的引用, 否则将当前String对象的引用地址（堆中）添加到字符串常量池中并返回。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123&quot;</span>).append(<span class="string">&quot;456&quot;</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>初识动态规划</title>
    <url>/2021/03/27/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划的简单介绍"><a href="#动态规划的简单介绍" class="headerlink" title="动态规划的简单介绍"></a>动态规划的简单介绍</h1><h2 id="从一道简单的题目开始："><a href="#从一道简单的题目开始：" class="headerlink" title="从一道简单的题目开始："></a>从一道简单的题目开始：</h2><blockquote>
<p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p>
</blockquote>
<a id="more"></a>

<p>对于编程来讲，这是非常非常容易入手的一道题目，我们可以从递归的思想入手：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于我们来说这样写无疑是最简单最容易理解的，只要理解递归的作用，这道题就能够很清楚的解出来，但是其实对于计算机来讲，并不是那样简单的工作，甚至我分析一下其实它相反做了很多多余的工作，我们可以画一个递归树来理解一下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goyh9x5umzj30ry0rsthz.jpg"></p>
<p>从这里可以看出，其实计算机重复计算了很多次的例如<code>fib(4)</code>、<code>fib(3)</code>、<code>fib(2)</code>,而算法是很讲究效率的，这样的解题方式虽然可以把结果算出来，但大量重复的计算同一个函数其实是得不偿失的，那么我们应该怎么样去处理这类包含着大量重复的子问题的题目呢？</p>
<p>如果在往下递归的时候，我们有时候可能会进行重复计算，那为什么不利用一定的内存空间把我们计算以后的结果保留下来呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] notebook = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span>( n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">      </span><br><span class="line">      Arrays.fill(notebook, <span class="number">0</span>);</span><br><span class="line">      notebook[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> fun(n-<span class="number">1</span>, notebook) + fun(n-<span class="number">2</span>,notebook);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] notebook)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span> &amp;&amp; notebook[n] == <span class="number">0</span>)&#123;</span><br><span class="line">            notebook[n] = fun(n-<span class="number">1</span>, notebook) + fun(n-<span class="number">2</span>, notebook);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> notebook[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们用了一个notebook的数组用来存放这样的一个结果，这样在事先走到最底层的时候，会把之前的结果保存下来，就不用一直计算之前的结果啦。</p>
<p>这道题还有一个很简单的办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> m1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            ans = m1 + m2;</span><br><span class="line">            m1 = m2;</span><br><span class="line">            m2 = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划-解题应用"><a href="#动态规划-解题应用" class="headerlink" title="动态规划 解题应用"></a>动态规划 解题应用</h2><p>像第二个解法一样，当我们面对一个问题的时候，如果待求解问题分解成若干个互相重叠的子问题，每个子问题对应决策过程的一个阶段，一般来说，子问题的重叠关系表现在对给定问题求解的递推关系中，我们将子问题的解求解一次并填入表中，当再次需要求解此问题子问题时就可以通过查表来获得该子问题的解，从而避免了大量的重复计算，这就是动态规划的思路，接下来我们看一道比较难一点的题目。</p>
<p>一般来说，一个动态规划的题目有这样几个阶梯的步骤：</p>
<ul>
<li>划分子问题：<ul>
<li>将原问题分解成若干个子问题，每个子问题对应一个决策阶段，并且子问题之间具有重叠关系</li>
</ul>
</li>
<li>确定动态规划函数（状态转移方程）：<ul>
<li>根据子问题之间的重叠关系找到子问题满足的递推关系式，也就是确定这个状态转移方程</li>
</ul>
</li>
<li>填写表格：<ul>
<li>设计表格（一般来说代码中是数组的存在），自底向上的方式计算各个子问题时的解并填到表中，实现动态规划的过程</li>
</ul>
</li>
</ul>
<p>我们看题目：</p>
<blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p>示例 1：</p>
<p>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br>(上箭头符号 ^ 表示选取的字母)<br>rabbbit<br>^^^^ ^^<br>rabbbit<br>^^ ^^^^<br>rabbbit<br>^^^ ^^^</p>
</blockquote>
<p>这道题就是一个很经典的动态规划，我们按照动态规划的解题思路来看这道题</p>
<ol>
<li><p>划分子问题：</p>
<ol>
<li>可以看到对于字符串s和字符串t，我们可以将问题缩小化，比如，对于s，我们可以将t分割成长度为1，2，3，len（t）这样长度的子串去处理，因为每一个t的长度为n的都可以由长度为n-1推导过来，同理，我们把这个思路放到s串上，s的长度为1，2，len（n），对于匹配字符串t来说他也是可分割的</li>
<li>经过之前的分析就可以知道，其实我们可以用一个二维数组去处理我们我们面对的这个问题，行数表示t字符串的位置，列数表示s字符串的列数，具体数组上的[i] [j]元素的值就表示s的0-i上的子串上t的0-j出现的次数</li>
</ol>
</li>
<li><p>填表看看规律，我们从示例出发建表：</p>
<ol>
<li><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goyk51tz65j30zb0rsqax.jpg" alt="IMG_18CCD1535F33-1"></li>
<li>最重要的就是从这样的一个表里看出他的递推规律，这样我们就可以开始写代码了，规律其实也不难<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goykc5by0xj31290rsk44.jpg" alt="IMG_88A03195CA8A-1"></li>
<li>这里我用橙色表示当i和j位置的字符不相等时的递推规律，用红色表示当i位置和j位置字符相等时的递推规律，这里唯一要注意的就是由于红色推导的时候，我们会上溯到i-1，j-1位置，就要判断当i=0时的特殊形式。</li>
</ol>
</li>
<li><p>写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = t.length();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            Arrays.fill(dp[i],<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == t.charAt(<span class="number">0</span>)) dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(t.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>这就是动态规划的一次进阶一点的使用，其实我们发现其实理清楚思路以后，动态规划也是一种暴力枚举，每种情况其实都有考虑到，只是在某些时候我们在做决策的时候（这里可以看作当我们在数组里填数字的时候），我们灵活的存放了我们应该记住的子问题的答案，从而完美递推到了最终问题的答案。道阻且长，加油吧！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
